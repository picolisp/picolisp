// 27may15abu
// (c) Software Lab. Alexander Burger

import java.util.*;
import java.math.*;
import java.io.*;
import java.net.*;
import java.nio.*;
import java.nio.channels.*;
import java.lang.reflect.*;

/* Ersatz PicoLisp Interpreter (Poor Man's PicoLisp) */
public class PicoLisp {
   final static Console Term = System.console();
   final static StringBuffer Line = new StringBuffer();
   final static Namespace Pico = new Namespace();
   final static Namespace Transient = new Namespace();
   final static byte MonLen[] = new byte[] {31,31,28,31,30,31,30,31,31,30,31,30,31};
   final static byte Version[] = new byte[] {<VERSION>};

   final static Number Zero = new Number(0);
   final static Number One = new Number(1);
   final static Number Two = new Number(2);

   final static NilSym Nil = new NilSym();
   final static Symbol pico = mkSymbol(new Symbol(Pico), "pico", Pico);
   final static Symbol T = mkSymbol(null, "T", Pico);
   final static Symbol Pid = mkSymbol(new Number(System.getProperty("PID")), "*Pid", Pico);
   final static Symbol At = mkSymbol(Nil, "@", Pico);
   final static Symbol At2 = mkSymbol(Nil, "@@", Pico);
   final static Symbol At3 = mkSymbol(Nil, "@@@", Pico);
   final static Symbol This = mkSymbol(Nil, "This", Pico);
   final static Symbol Prompt = mkSymbol(Nil, "*Prompt", Pico);
   final static Symbol Dbg = mkSymbol(Nil, "*Dbg", Pico);
   final static Symbol Scl = mkSymbol(Zero, "*Scl", Pico);
   final static Symbol Class = mkSymbol(Nil, "*Class", Pico);
   final static Symbol Run = mkSymbol(Nil, "*Run", Pico);
   final static Symbol Up = mkSymbol(Nil, "^", Pico);
   final static Symbol Err = mkSymbol(Nil, "*Err", Pico);
   final static Symbol Msg = mkSymbol(Nil, "*Msg", Pico);
   final static Symbol Uni = mkSymbol(Nil, "*Uni", Pico);
   final static Symbol Adr = mkSymbol(Nil, "*Adr", Pico);
   final static Symbol Bye = mkSymbol(Nil, "*Bye", Pico);

   final static Symbol Quote = mkSymbol(Zero, "quote", Pico);
   final static Symbol Meth = mkSymbol(One, "meth", Pico);

   final static String Delim = " \t\n\r\"'(),[]`~{}";

   static Catch Catch;
   static Env Env = new Env();
   static Process[] Pids = new Process[12];
   static PicoLispReader[] InFiles = new PicoLispReader[12];
   static PicoLispWriter[] OutFiles = new PicoLispWriter[12];
   final static PicoLispReader StdIn = new PicoLispReader(System.in, 0, null, 0);
   final static PicoLispWriter StdOut = new PicoLispWriter(System.out, 1);
   final static PicoLispWriter StdErr = new PicoLispWriter(System.err, 2);
   static PicoLispReader InFile = StdIn;
   static PicoLispWriter OutFile = StdOut;
   static Any TheCls, TheKey, Penv, Pnl;
   static String[] Argv;
   static String Home;
   static Calendar Cal;
   static int MaxFun;
   static long USec, Seed;
   static boolean Break, Jam, B;
   static Bind Brk;

   public static void main(String[] argv) {
      Argv = argv;
      <SYM> 1
      init();
      for (boolean first = true; ; first = false) {
         try {
            if (first)
               loadAll(null);
            for (;;)
               load(null, ':', Nil);
         }
         catch (Control e) {}
         catch (Throwable e) {error(null, null, e.toString());}
      }
   }

   final static void init() {
      int i;
      String s;
      Home = "";
      if (Argv.length > 0 && Argv[Argv.length-1].equals("+")) {
         Dbg.Car = T;
         String[] a = new String[Argv.length-1];
         System.arraycopy(Argv, 0, a, 0, a.length);
         Argv = a;
      }
      if (Argv.length > 0 && (s = Argv[0]).charAt(0) != '-' && ((i = s.lastIndexOf('/')) >= 0 && !(i == 1 && s.charAt(0) == '.')))
         Home = s.substring(0, i+1);
      try {
         if (Term != null) {
            final Pipe p = Pipe.open();
            StdIn.Chan = p.source();
            StdIn.Ops = SelectionKey.OP_READ;
            (new Thread() {
               public void run() {
                  for (;;) {
                     String s = Term.readLine();
                     if (s == null) {
                        StdOut.newline();
                        bye(0);
                     }
                     Line.append(s);
                     Line.append('\n');
                     try {p.sink().write(ByteBuffer.allocate(1));}
                     catch (IOException e) {giveup(e);}
                  }
               }
            } ).start();
         }
      }
      catch (IOException e) {giveup(e);}
      USec = System.nanoTime() / 1000;
   }

   final static void giveup(Exception e) {
      System.err.println(e);
      System.exit(1);
   }

   final static Any bye(int n) {
      if (!B) {
         B = true;
         unwind(null);
         Bye.Car.prog();
      }
      System.exit(n);
      return null;  /* Brain-dead Java */
   }

   final static Constructor javaConstructor(Class cls, Class[] par) throws NoSuchMethodException {
   looking:
      for (Constructor m : cls.getConstructors()) {
         Class<?>[] types = m.getParameterTypes();
         if (types.length == par.length) {
            for (int i = 0; i < types.length; ++i)
               if (!(types[i].isAssignableFrom(par[i])))
                  continue looking;
            return m;
         }
      }
      throw new NoSuchMethodException();
   }

   final static Method javaMethod(Class cls, String nm, Class[] par) throws NoSuchMethodException {
   looking:
      for (Method m : cls.getMethods()) {
         if (m.getName().equals(nm)) {
            Class<?>[] types = m.getParameterTypes();
            if (types.length == par.length) {
               for (int i = 0; i < types.length; ++i)
                  if (!(types[i].isAssignableFrom(par[i])))
                     continue looking;
               return m;
            }
         }
      }
      throw new NoSuchMethodException(nm);
   }

   final static int waitFd(Any ex, int fd, int ms) {
      int i;
      Selector sel;
      Any task = Env.Task,  at = At.Car;
      try {
         for (;;) {
            sel = Selector.open();
            int t = ms >= 0? ms : Integer.MAX_VALUE;
            if (fd >= 0 && InFiles[fd] != null)
               if (InFiles[fd].ready(sel))
                  t = 0;
               else
                  InFiles[fd].register(sel);
            for (Any x = Env.Task = Run.Car; x instanceof Cell; x = x.Cdr) {
               if (memq(x.Car, task) == null) {
                  if ((i = ((Number)x.Car.Car).Cnt) < 0) {
                     if ((i = ((Number)x.Car.Cdr.Car).Cnt) < t)
                        t = i;
                  }
                  else if (i != fd) {
                     if (i < InFiles.length && InFiles[i] != null)
                        if (InFiles[i].ready(sel))
                           t = 0;
                        else
                           InFiles[i].register(sel);
                  }
               }
            }
            long d = System.currentTimeMillis();
            if (t == 0)
               sel.selectNow();
            else
               sel.select(t);
            t = (int)(System.currentTimeMillis() - d);
            if (ms > 0  &&  (ms -= t) < 0)
               ms = 0;
            for (Any x = Env.Task; x instanceof Cell; x = x.Cdr) {
               if (memq(x.Car, task) == null) {
                  if ((i = ((Number)x.Car.Car).Cnt) < 0) {
                     if ((i = ((Number)x.Car.Cdr.Car).Cnt - t) > 0)
                        ((Number)x.Car.Cdr.Car).Cnt = i;
                     else {
                        ((Number)x.Car.Cdr.Car).Cnt = -((Number)x.Car.Car).Cnt;
                        At.Car = x.Car.Car;
                        x.Car.Cdr.Cdr.prog();
                     }
                  }
                  else if (i != fd) {
                     if (i < InFiles.length && InFiles[i] != null && InFiles[i].ready(sel)) {
                        At.Car = x.Car.Car;
                        x.Car.Cdr.prog();
                     }
                  }
               }
            }
            if (ms == 0 || fd < 0 || InFiles[fd] != null && InFiles[fd].ready(sel))
               break;
            sel.close();
         }
      }
      catch (IOException e) {giveup(e);}
      At.Car = at;
      Env.Task = task;
      return ms;
   }

   final static long initSeed(Any x) {
      long n;
      for (n = 0; x instanceof Cell; x = x.Cdr)
         n += initSeed(x.Car);
      if (x != Nil) {
         if (x instanceof Number && ((Number)x).Big == null)
            n += ((Number)x).Cnt;
         else {
            byte b[] = x instanceof Symbol? x.name().getBytes() : ((Number)x).Big.toByteArray();
            for (int i = 0; i < b.length; ++i)
               n += b[i];
         }
      }
      return n>=0? n*2 : -n*2+1;
   }

   final static Any date(int y, int m, int d) {
      int n;

      if (y<0 || m<1 || m>12 || d<1 || d>MonLen[m] && (m!=2 || d!=29 || y%4!=0 || y%100==0 && y%400!=0))
         return Nil;
      n = (12*y + m - 3) / 12;
      return new Number((4404*y+367*m-1094)/12 - 2*n + n/4 - n/100 + n/400 + d);
   }

   final static Any date(int n) {
      int y = (100*n - 20) / 3652425;
      n += (y - y/4);
      y = (100*n - 20) / 36525;
      n -= 36525*y / 100;
      int m = (10*n - 5) / 306;
      int d = (10*n - 306*m + 5) / 10;
      if (m < 10)
         m += 3;
      else {
         ++y;
         m -= 9;
      }
      return new Cell(new Number(y), new Cell(new Number(m), new Cell(new Number(d), Nil)));
   }

   final static Any time(Calendar cal) {
      return new Number(cal.get(Calendar.HOUR_OF_DAY) * 3600 + cal.get(Calendar.MINUTE) * 60 + cal.get(Calendar.SECOND));
   }

   final static Any time(int h, int m, int s) {
      if (h < 0  ||  m < 0 || m > 59  ||  s < 0 || s > 60)
         return Nil;
      return new Number(h * 3600 + m * 60 + s);
   }

   final static char firstChar(Any s) {
      String nm = s.name();
      return nm.length() == 0? '\0' : nm.charAt(0);
   }

   final static String path(String s) {
      if (s.length() > 0)
         if (s.charAt(0) == '+') {
            if (s.length() > 1 && s.charAt(1) == '@')
               return '+' + Home + s.substring(1);
         }
         else if (s.charAt(0) == '@')
            return Home + s.substring(1);
      return s;
   }

   final static void unwind(Catch target) {
      int i, j, n;
      Bind p;
      Catch q;
      Any x, y;
      while ((q = Catch) != null) {
         while ((p = Env.Bind) != null) {
            if ((i = p.Eswp) != 0) {
               j = i;  n = 0;
               for (;;) {
                  ++n;
                  if (++j == 0 || (p = p.Link) == null)
                     break;
                  if (p.Eswp < i)
                     --j;
               }
               do {
                  for (p = Env.Bind, j = n; --j != 0; p = p.Link);
                  if ((p.Eswp -= i) >= 0) {
                     if (p.Eswp > 0)
                        p.Eswp = 0;
                     for (j = p.Cnt; (j -= 2) >= 0;) {
                        y = p.Data[j+1];
                        x = y.Car;  y.Car = p.Data[j];  p.Data[j] = x;
                     }
                  }
               } while (--n != 0);
            }
            if (Env.Bind == q.Env.Bind)
               break;
            if (Env.Bind.Eswp == 0)
               for (i = Env.Bind.Cnt; (i -= 2) >= 0;)
                  Env.Bind.Data[i+1].Car = Env.Bind.Data[i];
            Env.Bind = Env.Bind.Link;
         }
         while (Env.InFrames != q.Env.InFrames)
            Env.popInFiles();
         while (Env.OutFrames != q.Env.OutFrames)
            Env.popOutFiles();
         Env = q.Env;
         q.Fin.eval();
         Catch = q.Link;
         if (q == target)
            return;
      }
      while (Env.Bind != null) {
         if (Env.Bind.Eswp == 0)
            for (i = Env.Bind.Cnt; (i -= 2) >= 0;)
               Env.Bind.Data[i+1].Car = Env.Bind.Data[i];
         Env.Bind = Env.Bind.Link;
      }
      while (Env.InFrames != null)
         Env.popInFiles();
      while (Env.OutFrames != null)
         Env.popOutFiles();
   }

   final static void error(Any ex, Any x, String msg) {
      Up.Car = ex == null? Nil : ex;
      if (msg.length() != 0) {
         Msg.Car = mkStr(msg);
         for (Catch p = Catch;  p != null;  p = p.Link) {
            Any y = p.Tag;
            if (y != null)
               while (y instanceof Cell) {
                  if (msg.indexOf(y.Car.name()) >= 0)
                     throw new Control(ex, p.Tag, y.Car == Nil? Msg.Car : y.Car);
                  y = y.Cdr;
               }
         }
      }
      InFile.Chr = 0;
      Break = false;
      Line.delete(0, Line.length());
      Env.pushOutFile(new OutFrame(OutFiles[2], 0));
      if (InFile.Name != null)
         StdErr.Wr.print('[' + InFile.Name + ':' + InFile.Src  + "] ");
      if (ex != null) {
         StdErr.Wr.print("!? ");
         StdErr.print(ex);
         StdErr.newline();
      }
      if (x != null) {
         StdErr.print(x);
         StdErr.Wr.print(" -- ");
      }
      if (msg.length() != 0) {
         StdErr.Wr.print(msg);
         StdErr.newline();
         if (Err.Car != Nil && !Jam) {
            Jam = true;
            Err.Car.prog();
            Jam = false;
         }
         load(null, '?', Nil);
      }
      unwind(null);
      Env.Intern = pico;
      Env.Args = null;
      Env.Next = 0;
      Env.Task = Env.Make = Env.Yoke = null;
   }

   final static Any err(Any ex, Any x, String msg) {
      error(ex, x, msg);
      throw new Control();
   }

   final static Any brkLoad(Any x) {
      if (!Break) {
         Break = true;
         OutFile.Wr.flush();
         Brk = new Bind();
         Brk.add(Up.Car);  Brk.add(Up);  Up.Car = x;
         Brk.add(Run.Car);  Brk.add(Run);  Run.Car = Nil;
         Brk.add(At.Car);  Brk.add(At);
         Env.Bind = Brk;
         Env.pushOutFile(new OutFrame(OutFiles[1], 0));
         OutFile.print(x);
         OutFile.newline();
         load(null, '!', Nil);
         Env.popOutFiles();
         At.Car = Brk.Data[4];
         Run.Car = Brk.Data[2];
         x = Up.Car;
         Up.Car = Brk.Data[0];
         Env.Bind = Brk.Link;
         Break = false;
      }
      return x;
   }

   final static void trace(int i, Any x, String s) {
      if (i > 64)
         i = 64;
      while (--i >= 0)
         StdErr.space();
      if (x instanceof Symbol)
         StdErr.print(x);
      else {
         StdErr.print(x.Car);
         StdErr.space();
         StdErr.print(x.Cdr);
         StdErr.space();
         StdErr.print(This.Car);
      }
      StdErr.Wr.print(s);
   }

   final static Any execError(Any x) {return err(null, x, "Can't execute");}
   final static Any protError(Any x) {return err(null, x, "Protected symbol");}
   final static Any symError(Any x) {return err(null, x, "Symbol expected");}
   final static Any symNsError(Any ex, Any x) {return err(ex, x, "Bad symbol namespace");}
   final static Any  argError(Any ex, Any x) {return err(ex, x, "Bad argument");}
   final static Any cntError(Any ex, Any x) {return err(ex, x, "Small number expected");}
   final static void needVar(Any ex, Any x) {if (x instanceof Number) err(ex, x, "Variable expected");}

   final static void badFd(Any ex, Any x) {err(ex, x, "Bad FD");}
   final static void makeError(Any ex) {err(ex, null, "Not making");}
   final static void closeErr(IOException e) {err(null, null, e.toString());}

   final static Any load(Any ex, char pr, Any x) {
      if (x instanceof Symbol && firstChar(x) == '-')
         return ((Symbol)x).parse(true,null).eval();
      Symbol ns = Env.Intern;
      Env.pushInFile(x.rdOpen(ex));
      Transient.clear();
      x = Nil;
      for (;;) {
         Any y;
         if (InFile != StdIn)
            y = InFile.read('\0');
         else {
            if (pr != '\0'  &&  InFile.Chr == 0) {
               OutFile.Wr.print(Prompt.Car.run().name() + pr);
               OutFile.space();
               OutFile.Wr.flush();
            }
            y = InFile.read('\n');
            while (InFile.Chr > 0) {
               if (InFile.Chr == '\n') {
                  InFile.Chr = 0;
                  break;
               }
               if (InFile.Chr == '#')
                  InFile.comment();
               else {
                  if (InFile.Chr > ' ')
                     break;
                  InFile.get();
               }
            }
         }
         if (y == Nil) {
            Env.Intern = ns;
            Env.popInFiles();
            Transient.clear();
            return x;
         }
         if (InFile != StdIn || InFile.Chr != 0 || pr == '\0')
            x = y.eval();
         else {
            Any at = At.Car;
            x = At.Car = y.eval();
            At3.Car = At2.Car;
            At2.Car = at;
            OutFile.Wr.print("-> ");
            OutFile.Wr.flush();
            OutFile.print(x);
            OutFile.newline();
         }
      }
   }

   final static String opt() {
      if (Argv.length == 0 || Argv[0].equals("-"))
         return null;
      String s = Argv[0];
      String[] a = new String[Argv.length-1];
      System.arraycopy(Argv, 1, a, 0, a.length);
      Argv = a;
      return s;
   }

   final static Any loadAll(Any ex) {
      String s;
      Any x = Nil;
      while ((s = opt()) != null)
         x = load(ex, '\0', mkStr(s));
      return x;
   }

   final static Any undefined(Any x, Any ex) {
      return err(ex, x, "Undefined");
   }

   final static Any[] append(Any[] a, int i, Any x) {
      if (i == a.length) {
         Any[] b = new Any[i*2];
         System.arraycopy(a, 0, b, 0, i);
         a = b;
      }
      a[i] = x;
      return a;
   }

   final static int allocPid() {
      int i;
      for (i = 2; Pids[i] != null; ++i) {
         if (i == Pids.length) {
            Process[] p = new Process[i*2];
            System.arraycopy(Pids, 0, p, 0, i);
            Pids = p;
            break;
         }
      }
      return i;
   }

   final static int allocFd() {
      int i;
      for (i = 3; InFiles[i] != null || OutFiles[i] != null; ++i) {
         if (i == InFiles.length) {
            PicoLispReader[] r = new PicoLispReader[i*2];
            System.arraycopy(InFiles, 0, r, 0, i);
            InFiles = r;
            PicoLispWriter[] w = new PicoLispWriter[i*2];
            System.arraycopy(OutFiles, 0, w, 0, i);
            OutFiles = w;
            break;
         }
      }
      return i;
   }

   final static Any mkSocket(SocketChannel chan) throws IOException {
      int i = allocFd();
      Socket sock = chan.socket();
      new PicoLispReader(sock.getInputStream(), i, chan, SelectionKey.OP_READ);
      new PicoLispWriter(sock.getOutputStream(), i);
      return new Number(i);
   }

   final static Any accept(Any ex, int i) {
      try {
         SocketChannel chan = ((ServerSocketChannel)InFiles[i].Chan).accept();
         Adr.Car = mkStr(chan.socket().getInetAddress().getHostAddress());
         return mkSocket(chan);
      }
      catch (IOException e) {}
      return null;
   }

   final static Any mkChar(int c) {return new Symbol(null, "" + (char)(c >= 0x10000? 0xFFFF : c));}
   final static Any mkStr(String nm) {return nm == null || nm.length() == 0? Nil : new Symbol(null, nm);}
   final static Any mkStr(StringBuilder sb) {return mkStr(sb.toString());}
   final static Symbol mkSymbol(Any val) {return new Symbol(val, null);}

   final static Symbol mkSymbol(Any val, String nm, Namespace table) {
      Symbol sym;
      if ((sym = table.get(nm)) == null) {
         sym = new Symbol(val, nm);
         table.put(nm, sym);
      }
      return sym;
   }

   final static Any strToNum(String s, int scl) throws NumberFormatException {
      if (s.length() != 0 && s.charAt(0) == '+')
         s = s.substring(1);
      if (s.indexOf('.') <= 0)
         return new Number(s);
      return new Number((new BigDecimal(s)).setScale(scl, RoundingMode.HALF_UP).unscaledValue());
   }

   final static Any format(Any z, int scl, Any x) {
      char sep = '.', ign = '\0';
      if (x instanceof Cell) {
         sep = firstChar(x.Car.eval());
         if ((x = x.Cdr) instanceof Cell)
            ign = firstChar(x.Car.eval());
      }
      if (z instanceof Number)
         return mkStr(((Number)z).toString(scl,sep,ign));
      String s = z.name();
      StringBuilder sb = new StringBuilder();
      for (int i = 0; i < s.length(); ++i) {
         char c = s.charAt(i);
         if (c != ign)
            sb.append(c == sep? '.' : c);
      }
      try {return strToNum(sb.toString(), scl);}
      catch (NumberFormatException e) {return Nil;}
   }

   final static Any fish(Any ex, Any foo, Any[] v, Any res) {
      if (foo.apply(ex, false, v, 1) != Nil)
         return new Cell(v[0], res);
      if (v[0] instanceof Cell) {
         Any x = v[0];
         if ((v[0] = x.Cdr) != Nil)
            res = fish(ex, foo, v, res);
         v[0] = x.Car;
         res = fish(ex, foo, v, res);
         v[0] = x;
      }
      return res;
   }

   final static Any all(Namespace table) {
      Any x = Nil;
      for (Iterator<Symbol> it = table.values().iterator(); it.hasNext();)
         x = new Cell(it.next(), x);
      return x;
   }

   final static Any meta(Any x, Any y) {
      Any z;
      for (; x instanceof Cell; x = x.Cdr)
         if (x.Car instanceof Symbol && ((z = x.Car.get(y)) != Nil || (z = meta(x.Car.Car, y)) != Nil))
            return z;
      return Nil;
   }

   final static boolean isa(Any cls, Any x) {
      Any z;
      z = x = x.Car;
      while (x instanceof Cell) {
         if (!(x.Car instanceof Cell)) {
            while (x.Car instanceof Symbol) {
               if (cls == x.Car || isa(cls, x.Car))
                  return true;
               if (!((x = x.Cdr) instanceof Cell) || z == x)
                  return false;
            }
            return false;
         }
         if (z == (x = x.Cdr))
            return false;
      }
      return false;
   }

   final static void redefMsg(Any x, Any y) {
      StdErr.Wr.print("# ");
      StdErr.print(x);
      if (y != null) {
         StdErr.space();
         StdErr.print(y);
      }
      StdErr.Wr.println(" redefined");
      StdErr.Wr.flush();
   }

   final static void putSrc(Symbol s, Any k) {
      if (Dbg.Car != Nil && InFile != null && InFile.Name != null) {
         Any x = new Cell(new Number(InFile.Src), mkSymbol(null, InFile.Name, Transient));
         Any y = s.get(Dbg);
         if (k == null) {
            if (y == Nil)
               s.put(Dbg, new Cell(x, Nil));
            else
               y.Car = x;
         }
         else if (y == Nil)
            s.put(Dbg, new Cell(Nil, new Cell(x, Nil)));
         else {
            for (Any z = y.Cdr; z instanceof Cell; z = z.Cdr)
               if (z.Car.Car == k) {
                  z.Car.Cdr = x;
                  return;
               }
            y.Cdr = new Cell(new Cell(k, x), y.Cdr);
         }
      }
   }

   final static void redefine(Symbol s, Any x) {
      if (s.Car != Nil  &&  s != s.Car  &&  !x.equal(s.Car))
         redefMsg(s, null);
      s.Car = x;
      putSrc(s, null);
   }

   final static int xInt(Any x) {return ((Number)x).Cnt;}
   final static int evInt(Any ex) {return ((Number)ex.Car.eval()).Cnt;}
   final static long xLong(Any x) {return ((Number)x).longValue();}
   final static long evLong(Any ex) {return ((Number)ex.Car.eval()).longValue();}
   final static String evString(Any ex) {return ex.Car.eval().name();}

   final static Any circ(Any x) {
      HashSet<Any> mark = new HashSet<Any>();
      if (!(x instanceof Cell))
         return null;
      for (;;) {
         mark.add(x);
         if (!((x = x.Cdr) instanceof Cell))
            return null;
         if (mark.contains(x))
            return x;
      }
   }

   final static Any fill(Any x, Any s) {
      Any y, z;
      if (x instanceof Number || x == Nil)
         return null;
      if (x instanceof Symbol)
         return x != x.Car && (s==Nil? x!=At && firstChar(x)=='@' : memq(x,s)!=null)? x.Car : null;
      if (x.Car == Up) {
         x = x.Cdr;
         if (!((y = x.Car.eval()) instanceof Cell))
            return (z = fill(x.Cdr, s)) == null? x.Cdr : z;
         Any w = y;
         while (y.Cdr instanceof Cell)
            y = y.Cdr;
         y.Cdr = (z = fill(x.Cdr, s)) == null? x.Cdr : z;
         return w;
      }
      if ((y = fill(x.Car, s)) != null) {
         z = fill(x.Cdr, s);
         return new Cell(y, z == null? x.Cdr : z);
      }
      if ((y = fill(x.Cdr, s)) != null)
         return new Cell(x.Car, y);
      return null;
   }

   final static boolean isBlank(Any x) {
      if (x != Nil) {
         if (!(x instanceof Symbol))
            return false;
         String s = x.name();
         if (s != null)
            for (int i = 0; i < s.length(); ++i)
               if (s.charAt(i) > ' ')
                  return false;
      }
      return true;
   }

   final static Any funq(Any x) {
      Any y;
      if (x == Nil || x instanceof Symbol)
         return Nil;
      if (x instanceof Number)
         return ((Number)x).Big == null && ((Number)x).Cnt <= MaxFun? x : Nil;
      if (circ(y = x.Cdr) != null)
         return Nil;
      while (y instanceof Cell) {
         if (y.Car instanceof Cell) {
            if (y.Car.Car instanceof Number) {
               if (y.Cdr instanceof Cell)
                  return Nil;
            }
            else if (y.Car.Car == Nil || y.Car.Car == T)
               return Nil;
         }
         else if (y.Cdr != Nil)
            return Nil;
         y = y.Cdr;
      }
      if (y != Nil)
         return Nil;
      if ((x = x.Car) == Nil)
         return T;
      if (circ(y = x) != null)
         return Nil;
      while (y instanceof Cell) {
         if (y.Car instanceof Number || y.Car instanceof Cell || y.Car == Nil || y.Car == T)
            return Nil;
         y = y.Cdr;
      }
      return y instanceof Number || y == T? Nil : x;
   }

   final static Any trim(Any x) {
      Any y;
      if (!(x instanceof Cell))
         return x;
      if ((y = trim(x.Cdr)) == Nil && isBlank(x.Car))
         return Nil;
      return new Cell(x.Car, y);
   }

   final static Any nCdr(int n, Any x) {
      while (--n >= 0)
         x = x.Cdr;
      return x;
   }

   final static Any nth(int n, Any x) {
      if (--n < 0)
         return Nil;
      return nCdr(n,x);
   }

   final static Any sort(Any ex, Any lst, Any foo) {
      Any x = lst, l = Nil, r = Nil, c = Nil;
      do {
         int i;
         if (foo == Nil)
            i = lst.Car.compare(x.Car);
         else if (lst.Car.equal(x.Car))
            i = 0;
         else
            i = foo.apply(ex, false, new Any[] {x.Car, lst.Car}, 2) == Nil? -1 : 1;
         if (i > 0)
            l = new Cell(x.Car, l);
         else if (i < 0)
            r = new Cell(x.Car, r);
         else
            c = new Cell(x.Car, c);
      } while ((x = x.Cdr) instanceof Cell);
      if ((lst = l) instanceof Cell) {
         if (l.Cdr instanceof Cell)
            for (lst = l = sort(ex, l, foo); (l = l.Cdr).Cdr instanceof Cell;);
         if (c instanceof Cell)
            for (l.Cdr = c; (l = l.Cdr).Cdr instanceof Cell;);
      }
      else if ((lst = c) instanceof Cell)
         for (l = c; l.Cdr instanceof Cell; l = l.Cdr);
      else
         return sort(ex, r, foo);
      if (r instanceof Cell)
         l.Cdr = r.Cdr instanceof Cell? sort(ex, r, foo) : r;
      return lst;
   }

   final static Any consIdx(Any x, Any y) {
      if (x.Cdr.Cdr instanceof Cell)
         y = consIdx(x.Cdr.Cdr, y);
      y = new Cell(x.Car, y);
      return x.Cdr.Car instanceof Cell? consIdx(x.Cdr.Car, y) : y;
   }

   final static Any idx(Any var, Any key, int flg) {
      Any x, y, z, p;
      boolean ad;
      int i;
      if (key == null)
         return var.Car instanceof Cell? consIdx(var.Car, Nil) : Nil;
      if (!((x = var.Car) instanceof Cell)) {
         if (flg > 0)
            var.Car = new Cell(key, Nil);
         return Nil;
      }
      p = var;
      ad = true;
      for (;;) {
         if ((i = key.compare(x.Car)) == 0) {
            if (flg < 0) {
               if (!(x.Cdr.Car instanceof Cell)) {
                  if (ad)
                     p.Car = x.Cdr.Cdr;
                  else
                     p.Cdr = x.Cdr.Cdr;
               }
               else if (!((y = x.Cdr.Cdr) instanceof Cell)) {
                  if (ad)
                     p.Car = x.Cdr.Car;
                  else
                     p.Cdr = x.Cdr.Car;
               }
               else if (!((z = y.Cdr.Car) instanceof Cell)) {
                  x.Car = y.Car;
                  x.Cdr.Cdr = y.Cdr.Cdr;
               }
               else {
                  while (z.Cdr.Car instanceof Cell)
                     z = (y = z).Cdr.Car;
                  x.Car = z.Car;
                  y.Cdr.Car = z.Cdr.Cdr;
               }
            }
            return x;
         }
         if (!(x.Cdr instanceof Cell)) {
            if (flg > 0)
               x.Cdr = i < 0? new Cell(new Cell(key, Nil), Nil) : new Cell(Nil, new Cell(key, Nil));
            return Nil;
         }
         if (i < 0) {
            if (!(x.Cdr.Car instanceof Cell)) {
               if (flg > 0)
                  x.Cdr.Car = new Cell(key, Nil);
               return Nil;
            }
            p = x.Cdr;  ad = true;
            x = p.Car;
         }
         else {
            if (!(x.Cdr.Cdr instanceof Cell)) {
               if (flg > 0)
                  x.Cdr.Cdr = new Cell(key, Nil);
               return Nil;
            }
            p = x.Cdr;  ad = false;
            x = p.Cdr;
         }
      }
   }

   final static Any consLup(Any x, Any y, Any from, Any to) {
      if (x instanceof Cell) {
         if (x.Car == T)
            return consLup(x.Cdr.Car, y, from, to);
         if (!(x.Car instanceof Cell))
            return consLup(x.Cdr.Cdr, y, from, to);
         if (to.compare(x.Car.Car) >= 0) {
            y = consLup(x.Cdr.Cdr, y, from, to);
            if (from.compare(x.Car.Car) <= 0) {
               y = new Cell(x.Car, y);
               return consLup(x.Cdr.Car, y, from, to);
            }
         }
         if (from.compare(x.Car.Car) <= 0)
            return consLup(x.Cdr.Car, y, from, to);
      }
      return y;
   }

   final static Any member(Any x, Any y) {
      Any z = y;

      while (y instanceof Cell) {
         if (x.equal(y.Car))
            return y;
         if (z == (y = y.Cdr))
            return null;
      }
      return y == Nil || !x.equal(y)? null : y;
   }

   final static Any memq(Any x, Any y) {
      Any z = y;

      while (y instanceof Cell) {
         if (x == y.Car)
            return y;
         if (z == (y = y.Cdr))
            return null;
      }
      return y == Nil || x != y? null : y;
   }

   final static int indx(Any x, Any y) {
      int i = 1;
      Any z = y;

      while (y instanceof Cell) {
         if (x.equal(y.Car))
            return i;
         ++i;
         if (z == (y = y.Cdr))
            return 0;
      }
      return 0;
   }

   final static boolean match(Any p, Any d) {
      Any x;
      for (;;) {
         if (!(p instanceof Cell)) {
            if (p instanceof Symbol  &&  firstChar(p) == '@') {
               p.Car = d;
               return true;
            }
            return p.equal(d);
         }
         if ((x = p.Car) instanceof Symbol  &&  firstChar(x) == '@') {
            if (!(d instanceof Cell)) {
               if (d.equal(p.Cdr)) {
                  x.Car = Nil;
                  return true;
               }
               return false;
            }
            if (match(p.Cdr, d.Cdr)) {
               x.Car = new Cell(d.Car, Nil);
               return true;
            }
            if (match(p.Cdr, d)) {
               x.Car = Nil;
               return true;
            }
            if (match(p, d.Cdr)) {
               x.Car = new Cell(d.Car, x.Car);
               return true;
            }
         }
         if (!(d instanceof Cell) || !match(x, d.Car))
            return false;
         p = p.Cdr;
         d = d.Cdr;
      }
   }

   final static boolean unify(Number n1, Any x1, Number n2, Any x2) {
      lookup1:
      while (x1 instanceof Symbol  &&  firstChar(x1) == '@') {
         for (Any x = Penv;  x.Car instanceof Cell;  x = x.Cdr)
            if (n1.Cnt == ((Number)x.Car.Car.Car).Cnt  &&  x1 == x.Car.Car.Cdr) {
               n1 = (Number)x.Car.Cdr.Car;
               x1 = x.Car.Cdr.Cdr;
               continue lookup1;
            }
         break;
      }
      lookup2:
      while (x2 instanceof Symbol  &&  firstChar(x2) == '@') {
         for (Any x = Penv;  x.Car instanceof Cell;  x = x.Cdr)
            if (n2.Cnt == ((Number)x.Car.Car.Car).Cnt  &&  x2 == x.Car.Car.Cdr) {
               n2 = (Number)x.Car.Cdr.Car;
               x2 = x.Car.Cdr.Cdr;
               continue lookup2;
            }
         break;
      }
      if (n1.Cnt == n2.Cnt  &&  x1.equal(x2))
         return true;
      if (x1 instanceof Symbol  &&  firstChar(x1) == '@') {
         if (x1 != At) {
            Penv = new Cell(new Cell(new Cell(n1,x1), Nil), Penv);
            Penv.Car.Cdr = new Cell(n2,x2);
         }
         return true;
      }
      if (x2 instanceof Symbol  &&  firstChar(x2) == '@') {
         if (x2 != At) {
            Penv = new Cell(new Cell(new Cell(n2,x2), Nil), Penv);
            Penv.Car.Cdr = new Cell(n1,x1);
         }
         return true;
      }
      if (!(x1 instanceof Cell) || !(x2 instanceof Cell))
         return x1.equal(x2);
      Any env = Penv;
      if (unify(n1, x1.Car, n2, x2.Car)  &&  unify(n1, x1.Cdr, n2, x2.Cdr))
         return true;
      Penv = env;
      return false;
   }

   final static Any lup(Number n, Any x) {
      lup:
      while (x instanceof Symbol  &&  firstChar(x) == '@') {
         for (Any y = Penv;  y.Car instanceof Cell;  y = y.Cdr)
            if (n.Cnt == ((Number)y.Car.Car.Car).Cnt  &&  x == y.Car.Car.Cdr) {
               n = (Number)y.Car.Cdr.Car;
               x = y.Car.Cdr.Cdr;
               continue lup;
            }
         break;
      }
      return x instanceof Cell? new Cell(lup(n, x.Car), lup(n, x.Cdr)) : x;
   }

   final static Any lookup(Number n, Any x) {
      return (x = lup(n,x)) instanceof Symbol && firstChar(x) == '@'?  Nil : x;
   }

   final static Any uniFill(Any x) {
      if (x instanceof Number)
         return x;
      if (x instanceof Symbol)
         return lup((Number)Pnl.Car, x);
      return new Cell(uniFill(x.Car), uniFill(x.Cdr));
   }

   final static Any evRun(boolean ev, Any x, int cnt, Any lst) {
      int i, j = cnt, n = 0;
      Bind b, bnd = Env.Bind;
      Any s, y, z;
      do {
         ++n;
         i = bnd.Eswp;
         bnd.Eswp -= cnt;
         if (i == 0) {
            for (i = 0; i < bnd.Cnt; i+= 2) {
               s = bnd.Data[i+1];
               y = s.Car;
               s.Car = bnd.Data[i];
               bnd.Data[i] = y;
            }
            if (bnd.Data[1] == At && --j == 0)
               break;
         }
      } while ((bnd = bnd.Link) != null);
      if (!(lst instanceof Cell))
         z = ev? x.eval() : x.run();
      else {
         bnd = new Bind();
         do {
            s = lst.Car;
            bnd.add(s.Car);
            bnd.add(s);
         exclude:
            for (b = Env.Bind, j = n; ;) {
               for (i = 0; i < b.Cnt; i+= 2)
                  if (s == b.Data[i+1]) {
                     s.Car = b.Data[i];
                     break exclude;
                  }
               if (--j == 0 || (b = b.Link) == null)
                  break;
            }
         } while ((lst = lst.Cdr) instanceof Cell);
         Env.Bind = bnd;
         z = ev? x.eval() : x.run();
         for (i = bnd.Cnt; (i -= 2) >= 0;)
            bnd.Data[i+1].Car = bnd.Data[i];
         Env.Bind = bnd.Link;
      }
      do {
         for (bnd = Env.Bind, i = n; --i != 0; bnd = bnd.Link);
         if ((bnd.Eswp += cnt) == 0)
            for (i = bnd.Cnt; (i -= 2) >= 0;) {
               s = bnd.Data[i+1];
               y = s.Car;
               s.Car = bnd.Data[i];
               bnd.Data[i] = y;
            }
      } while (--n > 0);
      return z;
   }

   final static Any evMethod(Any o, Any ex, Any x) {
      int i;
      Any y = ex.Car;
      Any cls = TheCls,  key = TheKey;
      Bind bnd = new Bind();  bnd.add(At.Car);  bnd.add(At);
      while (y instanceof Cell) {
         bnd.add(x.Car.eval());  // Save new value
         bnd.add(y.Car);  // and symbol
         x = x.Cdr;
         y = y.Cdr;
      }
      if (y == Nil || y != At) {
         i = bnd.Cnt;
         if (y != Nil) {
            bnd.add(y.Car);  // Save old value
            bnd.add(y);  // and symbol
            y.Car = x;  // Set new value
         }
         do {
            y = bnd.Data[--i];
            x = y.Car;
            y.Car = bnd.Data[--i];  // Set new value
            bnd.Data[i] = x;  // Save old value
         } while (i > 0);
         bnd.add(This.Car);
         bnd.add(This);
         This.Car = o;
         Env.Bind = bnd;
         y = cls;  cls = Env.Cls;  Env.Cls = y;
         y = key;  key = Env.Key;  Env.Key = y;
         x = ex.Cdr.prog();
      }
      else {
         int next, argc, j = 0;
         Any arg, args[], av[] = null;
         if (x instanceof Cell) {
            av = new Any[6];
            do
               av = append(av, j++, x.Car.eval());
            while ((x = x.Cdr) instanceof Cell);
         }
         next = Env.Next;  Env.Next = 0;
         argc = Env.ArgC;  Env.ArgC = j;
         arg = Env.Arg;    Env.Arg = Nil;
         args = Env.Args;  Env.Args = av;
         i = bnd.Cnt;
         do {
            y = bnd.Data[--i];
            x = y.Car;
            y.Car = bnd.Data[--i];  // Set new value
            bnd.Data[i] = x;  // Save old value
         } while (i > 0);
         bnd.add(This.Car);
         bnd.add(This);
         This.Car = o;
         Env.Bind = bnd;
         y = cls;  cls = Env.Cls;  Env.Cls = y;
         y = key;  key = Env.Key;  Env.Key = y;
         x = ex.Cdr.prog();
         Env.Args = args;
         Env.Arg = arg;
         Env.ArgC = argc;
         Env.Next = next;
      }
      for (i = bnd.Cnt; (i -= 2) >= 0;)
         bnd.Data[i+1].Car = bnd.Data[i];
      Env.Bind = bnd.Link;
      Env.Cls = cls;  Env.Key = key;
      return x;
   }

   final static Any method(Any x) {
      Any y, z;
      if ((y = x.Car) instanceof Cell) {
         while ((z = y.Car) instanceof Cell) {
            if (z.Car == TheKey)
               return z.Cdr;
            if (!((y = y.Cdr) instanceof Cell))
               return null;
         }
         do
            if ((x = method((TheCls = y).Car)) != null)
               return x;
         while ((y = y.Cdr) instanceof Cell);
      }
      return null;
   }

   final static Any extra(Any x) {
      Any y;
      for (x = x.Car; x.Car instanceof Cell; x = x.Cdr);
      while (x instanceof Cell) {
         if (x == Env.Cls  ||  (y = extra(x.Car)) == null) {
            while ((x = x.Cdr) instanceof Cell)
               if ((y = method((TheCls = x).Car)) != null)
                  return y;
            return null;
         }
         if (y != null  &&  y != T)
            return y;
         x = x.Cdr;
      }
      return T;
   }

   final static Any loop(Any x) {
      Any a, y, z;
      for (;;) {
         y = x;
         do {
            if ((z = y.Car) instanceof Cell) {
               if (z.Car == Nil) {
                  if ((a = (z = z.Cdr).Car.eval()) == Nil)
                     return z.Cdr.prog();
                  At.Car = a;
               }
               else if (z.Car == T) {
                  if ((a = (z = z.Cdr).Car.eval()) != Nil) {
                     At.Car = a;
                     return z.Cdr.prog();
                  }
               }
               else
                  z.eval();
            }
         } while ((y = y.Cdr) instanceof Cell);
      }
   }

   /* Ersatz PicoLisp Reader */
   final static class InFrame {
      InFrame Link;
      PicoLispReader Rd;
      int Pid;

      InFrame(PicoLispReader rd, int pid) {
         Link = Env.InFrames;
         Rd = rd;
         Pid = pid;
      }
   }

   final static class PicoLispReader {
      Reader Rd;
      String Name;
      char Eof1, Eof2;
      int Fd, Chr, Src, Ops;
      InputStream Stream;
      SelectableChannel Chan;
      SelectionKey Key;

      PicoLispReader(Reader rd, String nm, int fd, SelectableChannel chan, int ops) {
         Rd = rd;
         Name = nm;
         InFiles[Fd = fd] = this;
         Chan = chan;
         Ops = ops;
      }

      PicoLispReader(InputStream in, int fd, SelectableChannel chan, int ops) {
         this(in == null? null : new InputStreamReader(in), null, fd, chan, ops);
         Stream = in;
      }

      PicoLispReader(String s, char eof1, char eof2) {
         Rd = new StringReader(s);
         Eof1 = eof1;
         Eof2 = eof2;
      }

      final boolean register(Selector sel) {
         if (Ops != 0) {
            try {
               Chan.configureBlocking(false);
               Key = Chan.register(sel, Ops);
               return true;
            }
            catch (IOException e) {}
         }
         return false;
      }

      final boolean ready(Selector sel) throws IOException {
         if (Key == null)
            return Rd != null && Rd.ready() || Stream != null && Stream.available() > 0;
         boolean rdy = (Key.readyOps() & Ops) != 0;
         Key.cancel();
         Key = null;
         try{Chan.configureBlocking(true);}
         catch (IOException e) {}
         return rdy;
      }

      final void close() {
         try {
            if (Chan != null)
               Chan.close();
            if (Rd != null)
               Rd.close();
            InFiles[Fd] = null;
         }
         catch (IOException e) {closeErr(e);}
      }

      final void eofErr() {err(null, null, "EOF Overrun");}
      final void badInput() {err(null, null, "Bad input '" + (char)Chr + "'");}

      final int get() {
         try {
            if (this != StdIn || Term == null)
               Chr = Rd.read();
            else {
               while (Line.length() == 0) {
                  waitFd(null, 0, -1);
                  ((Pipe.SourceChannel)StdIn.Chan).read(ByteBuffer.allocate(1));
               }
               Chr = Line.charAt(0);
               Line.deleteCharAt(0);
            }
            if (Chr < 0) {
               if ((Chr = Eof1) != 0)
                  Eof1 = '\0';
               else if ((Chr = Eof2) != 0)
                  Eof2 = '\0';
               else
                  Chr = -1;
            }
            return Chr;
         }
         catch (IOException e) {return Chr = -1;}
      }

      final boolean eol() {
         if (Chr < 0)
            return true;
         if (Chr == '\n') {
            Chr = 0;
            return true;
         }
         if (Chr == '\r') {
            get();
            if (Chr == '\n')
               Chr = 0;
            return true;
         }
         return false;
      }

      final int skipc(int c) {
         if (Chr < 0)
            return Chr;
         for (;;) {
            while (Chr <= ' ') {
               get();
               if (Chr < 0)
                  return Chr;
            }
            if (Chr != c)
               return Chr;
            get();
            while (Chr != '\n') {
               if (Chr < 0)
                  return Chr;
               get();
            }
         }
      }

      final void comment() {
         get();
         if (Chr != '{') {
            while (Chr != '\n') {
               if (Chr < 0)
                  return;
               get();
            }
         }
         else {
            for (;;) {
               get();
               if (Chr < 0)
                  return;
               if (Chr == '}' && (get() == '#'))
                  break;
            }
            get();
         }
      }

      final int skip() {
         for (;;) {
            if (Chr < 0)
               return Chr;
            while (Chr <= ' ') {
               get();
               if (Chr < 0)
                  return Chr;
            }
            if (Chr != '#')
               return Chr;
            comment();
         }
      }

      final boolean testEsc() {
         for (;;) {
            if (Chr < 0)
               return false;
            if (Chr == '^') {
               get();
               if (Chr == '@')
                  badInput();
               if (Chr == '?')
                  Chr = 127;
               else
                  Chr &= 0x1F;
               return true;
            }
            if (Chr != '\\')
               return true;
            if (get() != '\n') {
               switch (Chr) {
               case 'n': Chr = '\n'; break;
               case 'r': Chr = '\r'; break;
               case 't': Chr = '\t'; break;
               default:
                  if ('0' <= Chr && Chr <= '9') {
                     int c = Chr - '0';

                     for (;;) {
                        get();
                        if (Chr == '\\')
                           break;
                        if (Chr < '0' || '9' < Chr)
                           badInput();
                        c = c * 10 + Chr - '0';
                     }
                     Chr = c;
                  }
               }
               return true;
            }
            do
               get();
            while (Chr == ' ' || Chr == '\t');
         }
      }

      final Any rdAtom(int c) {
         Namespace table = Env.intern();
         StringBuilder sb = new StringBuilder();
         sb.append((char)c);
         while (Chr > 0) {
            if (Chr == '~') {
               Symbol s = mkSymbol(null, sb.toString(), table);
               if (!(((Symbol)s.Car).Obj instanceof Namespace))
                  symNsError(null, s);
               table = (Namespace)((Symbol)s.Car).Obj;
               sb = new StringBuilder();
            }
            else {
               if (Delim.indexOf(Chr) >= 0)
                  break;
               if (Chr == '\\')
                  get();
               sb.append((char)Chr);
            }
            get();
         }
         String s = sb.toString();
         if (s.equals("NIL"))
            return Nil;
         try {return strToNum(s, ((Number)Scl.Car).Cnt);}
         catch (NumberFormatException e) {return mkSymbol(Nil, s, table);}
      }

      final Any rdList() {
         Any x, res;
         get();
         for (;;) {
            if (skip() == ')') {
               get();
               return Nil;
            }
            if (Chr == ']')
               return Nil;
            if (Chr != '~') {
               res = x = new Cell(read0(false), Nil);
               break;
            }
            get();
            if ((res = x = read0(false).eval()) instanceof Cell) {
               while (x.Cdr instanceof Cell)
                  x = x.Cdr;
               break;
            }
         }
         for (;;) {
            if (skip() == ')') {
               get();
               break;
            }
            if (Chr == ']')
               break;
            if (Chr == '.') {
               get();
               if (Delim.indexOf(Chr) >= 0) {
                  x.Cdr = skip()==')' || Chr==']'? res : read0(false);
                  if (skip() == ')')
                     get();
                  else if (Chr != ']')
                     err(null, x, "Bad dotted pair");
                  break;
               }
               x = x.Cdr = new Cell(rdAtom('.'), Nil);
            }
            else if (Chr != '~')
               x = x.Cdr = new Cell(read0(false), Nil);
            else {
               get();
               x.Cdr = read0(false).eval();
               while (x.Cdr instanceof Cell)
                  x = x.Cdr;
            }
         }
         return res;
      }

      final Any read0(boolean top) {
         Any x, y;
         if (skip() < 0) {
            if (top)
               return Nil;
            eofErr();
         }
         if (top && Rd instanceof LineNumberReader)
            Src = ((LineNumberReader)Rd).getLineNumber() + 1;
         if (Chr == '(') {
            x = rdList();
            if (top  &&  Chr == ']')
               get();
            return x;
         }
         if (Chr == '[') {
            x = rdList();
            if (Chr != ']')
               err(null, x, "Super parentheses mismatch");
            get();
            return x;
         }
         if (Chr == '\'') {
            get();
            return new Cell(Quote, read0(top));
         }
         if (Chr == ',') {
            get();
            x = read0(top);
            if (Uni.Car != T)
               x = (y = idx(Uni, x, 1)) instanceof Cell? y.Car : x;
            return x;
         }
         if (Chr == '`') {
            get();
            return read0(top).eval();
         }
         if (Chr == '"') {
            get();
            if (Chr == '"') {
               get();
               return Nil;
            }
            if (!testEsc())
               eofErr();
            StringBuilder sb = new StringBuilder();
            sb.append((char)Chr);
            while (get() != '"') {
               if (!testEsc())
                  eofErr();
               sb.append((char)Chr);
            }
            get();
            return mkSymbol(null, sb.toString(), Transient);
         }
         if (Chr == ')' || Chr == ']' || Chr == '~')
            badInput();
         if (Chr == '\\')
            get();
         int i = Chr;
         get();
         return rdAtom(i);
      }

      final Any read(int end) {
         if (Chr == 0)
            get();
         if (Chr == end)
            return Nil;
         return read0(true);
      }

      final Any token(Any x, char c) {
         if (Chr == 0)
            get();
         if (skipc(c) < 0)
            return null;
         if (Chr == '"') {
            get();
            if (Chr == '"') {
               get();
               return Nil;
            }
            if (!testEsc())
               return Nil;
            Any y = x = new Cell(mkChar(Chr), Nil);
            while (get() != '"' && testEsc())
               y = y.Cdr = new Cell(mkChar(Chr), Nil);
            get();
            return x;
         }
         if (Chr >= '0' && Chr <= '9') {
            StringBuilder sb = new StringBuilder();
            sb.append((char)Chr);
            while (get() >= '0' && Chr <= '9' || Chr == '.')
               sb.append((char)Chr);
            try {return strToNum(sb.toString(), ((Number)Scl.Car).Cnt);}
            catch (NumberFormatException e) {}
         }
         if (Chr != '+' && Chr != '-') {
            String s = x.name();
            if (Chr >= 'A' && Chr <= 'Z' || Chr == '\\' || Chr >= 'a' && Chr <= 'z' || s.indexOf(Chr) >= 0) {
               if (Chr == '\\')
                  get();
               StringBuilder sb = new StringBuilder();
               sb.append((char)Chr);
               while (get() >= '0' && Chr <= '9' || Chr >= 'A' && Chr <= 'Z' || Chr == '\\' || Chr >= 'a' && Chr <= 'z' || s.indexOf(Chr) >= 0) {
                  if (Chr == '\\')
                     get();
                  sb.append((char)Chr);
               }
               s = sb.toString();
               return s.equals("NIL")? Nil : mkSymbol(Nil, s, Env.intern());
            }
         }
         c = (char)Chr;
         get();
         return mkChar(c);
      }
   }

   /* Ersatz PicoLisp Printer */
   final static class OutFrame {
      OutFrame Link;
      PicoLispWriter Wr;
      int Pid;

      OutFrame(PicoLispWriter wr, int pid) {
         Link = Env.OutFrames;
         Wr = wr;
         Pid = pid;
      }
   }

   final static class PicoLispWriter {
      PrintWriter Wr;
      String Name;
      int Fd;

      PicoLispWriter(PrintWriter wr, String nm, int fd) {
         Wr = wr;
         Name = nm;
         OutFiles[Fd = fd] = this;
      }

      PicoLispWriter(OutputStream out, int fd) {
         this(new PrintWriter(out), null, fd);
      }

      final void close() {
         Wr.close();
         OutFiles[Fd] = null;
      }

      final void print(Any x) {Wr.print(x.toString());}
      final void space() {Wr.print(' ');}

      final void newline() {
         Wr.println();
         Wr.flush();
      }
   }

   /* Ersatz PicoLisp VM */
   final static class Bind {
      Bind Link;
      Any[] Data;
      int Cnt, Eswp;

      Bind() {
         Link = Env.Bind;
         Data = new Any[12];
      }

      final void add(Any x) {Data = append(Data, Cnt++, x);}
   }

   final static class Env {
      int Next, ArgC, Trace;
      Bind Bind;
      Symbol Intern;
      Any Arg, Args[], Cls, Key, Task, Make, Yoke;
      InFrame InFrames;
      OutFrame OutFrames;

      Env() {Intern = pico;}

      Env(Env env) {
         Next = env.Next;  ArgC = env.ArgC;  Trace = env.Trace;
         Bind = env.Bind;
         Intern = env.Intern;
         Arg = env.Arg;  Args = env.Args;
         Cls = env.Cls;  Key = env.Key;
         Task = env.Task;
         Make = env.Make;  Yoke = env.Yoke;
         InFrames = env.InFrames;  OutFrames = env.OutFrames;
      }

      final Namespace intern() {
         return (Namespace)((Symbol)Intern.Car).Obj;
      }

      final void pushInFile(InFrame in) {
         InFrames = in;
         InFile = InFiles[in.Rd.Fd];
      }

      final void popInFiles() {
         if (InFrames.Pid != 0) {
            InFile.close();
            if (InFrames.Pid > 1) {
               try {
                  Pids[InFrames.Pid].waitFor();
                  Pids[InFrames.Pid] = null;
               }
               catch (InterruptedException e) {}  //#! sighandler()
            }
         }
         InFile = (InFrames = InFrames.Link) == null? StdIn : InFiles[InFrames.Rd.Fd];
      }

      final void pushOutFile(OutFrame out) {
         OutFrames = out;
         OutFile = OutFiles[out.Wr.Fd];
      }

      final void popOutFiles() {
         if (OutFrames.Pid != 0) {
            OutFile.close();
            if (OutFrames.Pid > 1) {
               try {
                  Pids[OutFrames.Pid].waitFor();
                  Pids[OutFrames.Pid] = null;
               }
               catch (InterruptedException e) {}  //#! sighandler()
            }
         }
         OutFile = (OutFrames = OutFrames.Link) == null? StdOut : OutFiles[OutFrames.Wr.Fd];
      }
   }

   final static class Catch {
      Catch Link;
      Any Tag, Fin;
      Env Env;

      Catch(Any tag, Any fin, Env env) {
         Tag = tag;
         Fin = fin;
         Env = new Env(env);
         Link = Catch;  Catch = this;
      }
   }

   final static class Control extends RuntimeException {
      Any Tag, Val;

      Control() {}

      Control(Any ex, Any tag, Any val) {
         Tag = tag;
         Val = val;
         for (Catch p = Catch; p != null; p = p.Link)
            if (p.Tag == T  ||  p.Tag == tag) {
               unwind(p);
               return;
            }
         err(ex, tag, "Tag not found");
      }
   }

   final static class Namespace extends HashMap<String,Symbol> {
      final void copy(Namespace table) {
         for (Iterator<Symbol> it = values().iterator(); it.hasNext();) {
            Symbol sym = it.next();
            if (table.get(sym.Name) == null)
               table.put(sym.Name, sym);
         }
      }
   }

   static abstract class Any {
      Any Car, Cdr;

      abstract Any put(Any key, Any val);
      abstract Any get(Any key);
      abstract Any prop(Any key);
      abstract Any putl(Any lst);
      abstract Any getl();
      abstract Any eval();
      abstract Any prog();
      abstract Any run();
      abstract Any call(Any ex);
      abstract Any func(Any ex);
      abstract Any apply(Any ex, boolean cf, Any[] v, int n);
      abstract boolean equal(Any x);
      abstract int compare(Any x);
      abstract long length();
      abstract long size();
      abstract InFrame rdOpen(Any ex);
      abstract OutFrame wrOpen(Any ex);
      abstract String name();
   }

   final static class Number extends Any {
      int Cnt;
      BigInteger Big;

      Number(int i) {Cnt = i;}

      Number(long n) {
         if (n >= Integer.MIN_VALUE  && n <= Integer.MAX_VALUE)
            Cnt = (int)n;
         else
            Big = new BigInteger(new byte[] {(byte)(n>>56), (byte)(n>>48), (byte)(n>>40), (byte)(n>>32), (byte)(n>>24), (byte)(n>>16), (byte)(n>>8), (byte)n});
      }

      Number(BigInteger b) {
         if (b.bitLength() < 32)
            Cnt = b.intValue();
         else
            Big = b;
      }

      Number(String s) {
         try {Cnt = Integer.parseInt(s);}
         catch (NumberFormatException e) {Big = new BigInteger(s);}
      }

      final long longValue() {return Big == null? Cnt : Big.longValue();}

      final static BigInteger big(int i) {
         return new BigInteger(new byte[] {(byte)(i>>24), (byte)(i>>16), (byte)(i>>8), (byte)i});
      }

      final Any put(Any key, Any val) {return symError(this);}
      final Any get(Any key) {return symError(this);}
      final Any prop(Any key) {return symError(this);}
      final Any putl(Any lst) {return symError(this);}
      final Any getl() {return symError(this);}
      final Any eval() {return this;}
      final Any prog() {return execError(this);}
      final Any run() {return execError(this);}
      final Any call(Any ex) {return ex;}

      final Any func(Any ex) {
         try {
            switch(Cnt) {
            case 0:  // (quote . any) -> any
               return ex.Cdr;
            case 1:  // (meth 'obj ['any ..]) -> any
               return doMeth(ex);
            <FUN> 1
            default:
               return undefined(this, ex);
            }
         }
         catch (Throwable e) {
            if (e instanceof Control)
               throw (Control)e;
            return err(ex, null, e.toString());
         }
      }

      final static Any doMeth(Any ex) {
         Any x, y, z;
         z = (x = ex.Cdr).Car.eval();
         for (TheKey = ex.Car; ; TheKey = TheKey.Car)
            if (TheKey.Car instanceof Number) {
               TheCls = null;
               if ((y = method(z)) != null)
                  return evMethod(z, y, x.Cdr);
               err(ex, TheKey, "Bad message");
            }
      }

      <DEF> 1

      final Any apply(Any ex, boolean cf, Any[] v, int n) {
         Any x, y = Nil;
         if (n > 0) {
            y = x = new Cell(mkSymbol(cf? v[0].Car : v[0]), Nil);
            for (int i = 1; i < n; ++i)
               x = x.Cdr = new Cell(mkSymbol(cf? v[i].Car : v[i]), Nil);
         }
         return func(new Cell(this, y));
      }

      final boolean equal(Any x) {
         if (x == this)
            return true;
         if (!(x instanceof Number))
            return false;
         Number num = (Number)x;
         if (Big == null)
            return num.Big == null && Cnt == num.Cnt;
         return Big.equals(num.Big);
      }

      final int compare(Any x) {
         if (x == this)
            return 0;
         if (x == Nil)
            return +1;
         if (!(x instanceof Number))
            return -1;
         Number num = (Number)x;
         if (Big == null) {
            if (num.Big == null)
               return Cnt == num.Cnt? 0 : Cnt > num.Cnt? 1 : -1;
            return -num.Big.signum();
         }
         if (num.Big == null)
            return Big.signum();
         return Big.compareTo(num.Big);
      }

      final long length() {return (Big == null? Integer.toString(Cnt) : Big.toString()).length();}

      final long size() {
         if (Big == null) {
            int n = 2 * (Cnt >= 0? Cnt : -Cnt);
            if (n == 0)
               return 1;
            int i = 1;
            while ((n >>= 8) != 0)
               ++i;
            return i;
         }
         return Big.toByteArray().length;
      }

      final InFrame rdOpen(Any ex) {
         int i;
         InFrame f;
         if ((i = Cnt) < 0) {
            for (f = Env.InFrames;;) {
               if ((f = f.Link) == null)
                  badFd(ex, this);
               if (++i == 0) {
                  i = f.Rd.Fd;
                  break;
               }
            }
         }
         if (i >= InFiles.length || InFiles[i] == null)
            badFd(ex, this);
         return new InFrame(InFiles[i],0);
      }

      final OutFrame wrOpen(Any ex) {
         int i;
         OutFrame f;
         if ((i = Cnt) < 0) {
            for (f = Env.OutFrames;;) {
               if ((f = f.Link) == null)
                  badFd(ex, this);
               if (++i == 0) {
                  i = f.Wr.Fd;
                  break;
               }
            }
         }
         if (i >= OutFiles.length || OutFiles[i] == null)
            badFd(ex, this);
         return new OutFrame(OutFiles[i],0);
      }

      final String name() {return Big == null? Integer.toString(Cnt) : Big.toString();}
      final public String toString() {return name();}

      final public String toString(int scl, char sep, char ign) {
         String s = name();
         StringBuilder sb = new StringBuilder();
         if (s.charAt(0) == '-') {
            sb.append('-');
            s = s.substring(1);
         }
         if ((scl = s.length() - scl - 1) < 0) {
            sb.append('0');
            sb.append(sep);
            while (scl < -1) {
               sb.append('0');
               ++scl;
            }
         }
         for (int i = 0;;) {
            sb.append(s.charAt(i++));
            if (i == s.length())
               return sb.toString();
            if (scl == 0)
               sb.append(sep);
            else if (ign != '\0'  &&  scl > 0  &&  scl % 3 == 0)
               sb.append(ign);
            --scl;
         }
      }

      final Number abs() {
         if (Big == null) {
            if (Cnt >= 0)
               return this;
            if (Cnt != Integer.MIN_VALUE)
               return new Number(-Cnt);
            return new Number(-(long)Cnt);
         }
         return new Number(Big.abs());
      }

      final Number neg() {
         if (Big == null) {
            if (Cnt != Integer.MIN_VALUE)
               return new Number(-Cnt);
            return new Number(-(long)Cnt);
         }
         return new Number(Big.negate());
      }

      final Number add(Number num) {
         if (Big == null) {
            if (num.Big == null)
               return new Number((long)Cnt + (long)num.Cnt);
            return new Number(big(Cnt).add(num.Big));
         }
         if (num.Big == null)
            return new Number(Big.add(big(num.Cnt)));
         return new Number(Big.add(num.Big));
      }

      final Number sub(Number num) {
         if (Big == null) {
            if (num.Big == null)
               return new Number((long)Cnt - (long)num.Cnt);
            return new Number(big(Cnt).subtract(num.Big));
         }
         if (num.Big == null)
            return new Number(Big.subtract(big(num.Cnt)));
         return new Number(Big.subtract(num.Big));
      }

      final Number mul(Number num) {
         if (Big == null) {
            if (num.Big == null)
               return new Number((long)Cnt * (long)num.Cnt);
            return new Number(big(Cnt).multiply(num.Big));
         }
         if (num.Big == null)
            return new Number(Big.multiply(big(num.Cnt)));
         return new Number(Big.multiply(num.Big));
      }

      final Number div(Number num) {
         if (Big == null) {
            if (num.Big == null)
               return new Number((long)Cnt / (long)num.Cnt);
            return new Number(big(Cnt).divide(num.Big));
         }
         if (num.Big == null)
            return new Number(Big.divide(big(num.Cnt)));
         return new Number(Big.divide(num.Big));
      }

      final Number rem(Number num) {
         if (Big == null) {
            if (num.Big == null)
               return new Number((long)Cnt % (long)num.Cnt);
            return new Number(big(Cnt).remainder(num.Big));
         }
         if (num.Big == null)
            return new Number(Big.remainder(big(num.Cnt)));
         return new Number(Big.remainder(num.Big));
      }

      final Number shift(int i) {
         if (Big == null) {
            if (i >= 0)
               return new Number((long)Cnt >> i);
            if (i > -32)
               return new Number((long)Cnt << -i);
            return new Number((new BigInteger(new byte[] {(byte)(Cnt>>24), (byte)(Cnt>>16), (byte)(Cnt>>8), (byte)Cnt})).shiftRight(i));
         }
         return new Number(Big.shiftRight(i));
      }

      final boolean tst(Number num) {
         if (Big == null) {
            if (num.Big == null)
               return Cnt == (Cnt & num.Cnt);
            BigInteger b = big(Cnt);
            return b.equals(b.and(num.Big));
         }
         if (num.Big == null)
            return Big.equals(Big.and(big(num.Cnt)));
         return Big.equals(Big.and(num.Big));
      }

      final Number and(Number num) {
         if (Big == null) {
            if (num.Big == null)
               return new Number((long)Cnt & (long)num.Cnt);
            return new Number(big(Cnt).and(num.Big));
         }
         if (num.Big == null)
            return new Number(Big.and(big(num.Cnt)));
         return new Number(Big.and(num.Big));
      }

      final Number or(Number num) {
         if (Big == null) {
            if (num.Big == null)
               return new Number((long)Cnt | (long)num.Cnt);
            return new Number(big(Cnt).or(num.Big));
         }
         if (num.Big == null)
            return new Number(Big.or(big(num.Cnt)));
         return new Number(Big.or(num.Big));
      }

      final Number xor(Number num) {
         if (Big == null) {
            if (num.Big == null)
               return new Number((long)Cnt ^ (long)num.Cnt);
            return new Number(big(Cnt).xor(num.Big));
         }
         if (num.Big == null)
            return new Number(Big.xor(big(num.Cnt)));
         return new Number(Big.xor(num.Big));
      }
   }

   final static class Symbol extends Any {
      Object Obj;
      Any Prop[];
      String Name;

      Symbol(Any val, String nm) {
         Car = val == null? this : val;
         Name = nm;
      }

      Symbol(Object obj) {
         Car = this;
         Obj = obj;
      }

      final void wipe() {
         Car = Nil;
         Prop = null;
      }

      final Any put(Any key, Any val) {
         if (key.equal(Zero))
            Car = val;
         else if (Prop != null) {
            Any x;
            int i = Prop.length, p = -1;
            do {
               if ((x = Prop[--i]) == null)
                  p = i;
               else if (x instanceof Cell) {
                  if (key == x.Cdr) {
                     if (val == Nil)
                        Prop[i] = null;
                     else if (val == T)
                        Prop[i] = key;
                     else
                        x.Car = val;
                     return val;
                  }
               }
               else if (key == x) {
                  if (val == Nil)
                     Prop[i] = null;
                  else if (val != T)
                     Prop[i] = new Cell(val, key);
                  return val;
               }
            } while (i != 0);
            if (val != Nil) {
               if (p < 0) {
                  Any[] a = new Any[(p = Prop.length) * 2];
                  System.arraycopy(Prop, 0, a, 0, p);
                  Prop = a;
               }
               Prop[p] = val != T? new Cell(val, key) : key;
            }
         }
         else if (val != Nil)
            (Prop = new Any[3])[2] = val != T? new Cell(val, key) : key;
         return val;
      }

      final Any get(Any key) {
         if (key.equal(Zero))
            return Car;
         if (Prop == null)
            return Nil;
         Any x;
         int i = Prop.length;
         do {
            if ((x = Prop[--i]) != null) {
               if (x instanceof Cell) {
                  if (key == x.Cdr)
                     return x.Car;
               }
               else if (key == x)
                  return T;
            }
         } while (i != 0);
         return Nil;
      }

      final Any prop(Any key) {
         Any x;

         if (Prop == null) {
            (Prop = new Any[3])[2] = x = new Cell(Nil, key);
            return x;
         }
         int i = Prop.length, p = -1;
         do {
            if ((x = Prop[--i]) == null)
               p = i;
            else if (x instanceof Cell) {
               if (key == x.Cdr)
                  return x;
            }
            else if (key == x)
               return key;
         } while (i != 0);
         if (p < 0) {
            Any[] a = new Any[(p = Prop.length) * 2];
            System.arraycopy(Prop, 0, a, 0, p);
            Prop = a;
         }
         Prop[p] = x = new Cell(Nil, key);
         return x;
      }

      final Any putl(Any lst) {
         Prop = new Any[6];
         int i = 0;
         for (Any y = lst; y instanceof Cell; y = y.Cdr)
            Prop = append(Prop, i++, y.Car);
         return lst;
      }

      final Any getl() {
         Any x = Nil;
         if (Prop != null)
            for (int i = Prop.length; --i >= 0;)
               if (Prop[i] != null)
                  x = new Cell(Prop[i], x);
         return x;
      }

      final Any eval() {return Car;}
      final Any prog() {return Car;}
      final Any run() {return Car;}

      final Any call(Any ex) {
         if (Car == Nil)
            undefined(this, ex);
         return Car.func(ex);
      }

      final Any func(Any ex) {return Car.func(ex);}

      final Any apply(Any ex, boolean cf, Any[] v, int n) {
         if (Car == Meth.Car) {
            Any x, y, z, o = cf? v[0].Car : v[0];
            TheCls = null;  TheKey = this;
            if ((z = method(o)) != null) {
               int i;
               Any cls = Env.Cls;  Any key = Env.Key;
               Env.Cls = TheCls;  Env.Key = TheKey;
               Bind bnd = new Bind();  bnd.add(At.Car);  bnd.add(At);
               for (x = z.Car, i = 0; x instanceof Cell; ++i) {
                  bnd.add((y = x.Car).Car);  // Save value
                  bnd.add(y);  // and symbol
                  y.Car = i >= n? Nil : cf? v[i].Car : v[i];
                  x = x.Cdr;
               }
               if (x == Nil || x != At) {
                  if (x != Nil) {
                     bnd.add(x.Car);  // Save value
                     bnd.add(x);  // and symbol
                     x.Car = Nil;  // Set to NIL
                     while (--n >= i)
                        x.Car = new Cell(mkSymbol(cf? v[n].Car : v[n]), x.Car);
                  }
                  bnd.add(This.Car);
                  bnd.add(This);
                  This.Car = o;
                  Env.Bind = bnd;
                  x = z.Cdr.prog();
               }
               else {
                  int next, argc, j = 0;
                  Any arg, args[], av[] = null;
                  if (i < n) {
                     av = new Any[6];
                     do
                        av = append(av, j++, x.Car.eval());
                     while (++i < n);
                  }
                  next = Env.Next;  Env.Next = 0;
                  argc = Env.ArgC;  Env.ArgC = j;
                  arg = Env.Arg;    Env.Arg = Nil;
                  args = Env.Args;  Env.Args = av;
                  bnd.add(This.Car);
                  bnd.add(This);
                  This.Car = o;
                  Env.Bind = bnd;
                  x = z.Cdr.prog();
                  Env.Args = args;
                  Env.Arg = arg;
                  Env.ArgC = argc;
                  Env.Next = next;
               }
               for (i = bnd.Cnt; (i -= 2) >= 0;)
                  bnd.Data[i+1].Car = bnd.Data[i];
               Env.Bind = bnd.Link;
               Env.Cls = cls;  Env.Key = key;
               return x;
            }
            err(ex, o, "Bad object");
         }
         if (Car == Nil || Car == this)
            undefined(this, ex);
         return Car.apply(ex, cf, v, n);
      }

      final boolean equal(Any x) {
         if (x == this)
            return true;
         if (x instanceof Symbol) {
            Symbol s = (Symbol)x;
            if (Name != null)
               return Name.equals(s.Name);
            if (Obj != null)
               return Obj.equals(s.Obj);
         }
         return false;
      }

      final int compare(Any x) {
         if (x == this)
            return 0;
         if (this == T || x == Nil || x instanceof Number)
            return +1;
         if (x == T  || x instanceof Cell)
            return -1;
         String a = Name;
         String b = ((Symbol)x).Name;
         if (a == null)
            return b == null? hashCode() - x.hashCode() : -1;
         if (b == null)
            return +1;
         return a.compareTo(b);
      }

      final long length() {return name().length();}
      final long size() {return name().getBytes().length;}

      final InFrame rdOpen(Any ex) {
         try {
            String nm = path(name());
            if (nm.charAt(0) == '+')
               nm = nm.substring(1);  // No file reader with "rw" mode
            return new InFrame(new PicoLispReader(new LineNumberReader(new FileReader(nm)), nm, allocFd(), null, 0), 1);
         }
         catch (IOException e) {
            err(ex, this, "Read open error");
            return null;
         }
      }

      final OutFrame wrOpen(Any ex) {
         try {
            String nm = path(name());
            if (nm.charAt(0) == '+')
               return new OutFrame(new PicoLispWriter(new PrintWriter(new FileWriter(nm.substring(1), true)), nm, allocFd()), 1);
            return new OutFrame(new PicoLispWriter(new PrintWriter(nm), nm, allocFd()), 1);
         }
         catch (IOException e) {
            err(ex, this, "Write open error");
            return null;
         }
      }

      final String name() {return Name != null? Name : Obj == null? "" : Obj.toString();}

      final public String toString() {
         if (Name == null) {
            String s;
            if (Obj == null)
               return "$" + hashCode();
            int i = (s = Obj.getClass().toString()).lastIndexOf('.');
            if (i >= 0)
               s = s.substring(i + 1);
            if (s.startsWith("class "))
               s = s.substring(6);
            return '$' + s;

         }
         if (Env.intern().get(Name) == this) {
            if (Name.equals("."))
               return "\\.";
            StringBuilder sb = new StringBuilder();
            if (Name.charAt(0) == '#')
               sb.append('\\');
            for (int i = 0; i < Name.length(); ++i) {
               char c = Name.charAt(i);
               if (c == '\\' || Delim.indexOf(c) >= 0)
                  sb.append('\\');
               sb.append(c);
            }
            return sb.toString();
         }
         StringBuilder sb = new StringBuilder();
         sb.append('\"');
         for (int i = 0; i < Name.length(); ++i) {
            char c = Name.charAt(i);
            if (c == '\\' || c == '^' || c == '"')
               sb.append('\\');
            else if (c == 127)
               {sb.append('^');  c = '?';}
            else if (c < ' ')
               {sb.append('^');  c |= 0x40;}
            sb.append(c);
         }
         sb.append('\"');
         return sb.toString();
      }

      final Any parse(boolean skp, Any s) {
         Any x, y, z;
         PicoLispReader rd;
         if (s == null)
            rd = new PicoLispReader(name(), '\n', ']');
         else
            rd = new PicoLispReader(name(), '\0', '\0');
         if (skp)
            rd.get();
         if (s == null)
            return rd.rdList();
         if ((x = rd.token(s, '\0')) == null)
            return Nil;
         z = y = new Cell(x, Nil);
         while ((x = rd.token(s, '\0')) != null)
            y = y.Cdr = new Cell(x, Nil);
         return z;
      }
   }


   final static class NilSym extends Any {
      NilSym() {
         Car = this;
         Cdr = this;
      }

      final Any put(Any key, Any val) {return protError(this);}
      final Any get(Any key) {return this;}
      final Any prop(Any key) {return this;}
      final Any putl(Any lst) {return protError(this);}
      final Any getl() {return protError(this);}
      final Any eval() {return this;}
      final Any prog() {return this;}
      final Any run() {return this;}
      final Any call(Any ex) {return undefined(this,ex);}
      final Any func(Any ex) {return undefined(this,ex);}
      final Any apply(Any ex, boolean cf, Any[] v, int n) {return undefined(this,ex);}
      final boolean equal(Any x) {return x == Nil;}
      final int compare(Any x) {return x == this? 0 : -1;}
      final long length() {return 0;}
      final long size() {return 0;}
      final InFrame rdOpen(Any ex) {return new InFrame(InFiles[0], 0);}
      final OutFrame wrOpen(Any ex) {return new OutFrame(OutFiles[1], 0);}
      final String name() {return "";}
      final public String toString() {return "NIL";}
   }

   final static class Cell extends Any {
      Cell(Any car, Any cdr) {
         Car = car;
         Cdr = cdr;
      }

      final Any put(Any key, Any val) {return symError(this);}

      final Any get(Any key) {
         Any x, y = this;
         if (key instanceof Number) {
            int n = ((Number)key).Cnt;
            if (n > 0) {
               while (--n != 0)
                  y = y.Cdr;
               return y.Car;
            }
            if (n < 0) {
               while (++n != 0)
                  y = y.Cdr;
               return y.Cdr;
            }
         }
         else
            do
               if ((x = y.Car) instanceof Cell  &&  key == x.Car)
                  return x.Cdr;
            while ((y = y.Cdr) instanceof Cell);
         return Nil;
      }

      final Any prop(Any key) {return symError(this);}
      final Any putl(Any lst) {return symError(this);}
      final Any getl() {return symError(this);}
      final Any eval() {return Car.call(this);}

      final Any prog() {
         Any ex;
         for (ex = this; ex.Cdr != Nil; ex = ex.Cdr)
            ex.Car.eval();
         return ex.Car.eval();
      }

      final Any run() {
         Any x, at = At.Car;
         Any ex = this;
         do
            x = ex.Car.eval();
         while ((ex = ex.Cdr) != Nil);
         At.Car = at;
         return x;
      }

      final Any call(Any ex) {return eval().func(ex);}

      final Any func(Any ex) {
         int i;
         Any x, y;
         Bind bnd = new Bind();  bnd.add(At.Car);  bnd.add(At);
         for (x = Car; x instanceof Cell; x = x.Cdr) {
            bnd.add((ex = ex.Cdr).Car.eval());  // Save new value
            bnd.add(x.Car);  // and symbol
         }
         if (x == Nil || x != At) {
            i = bnd.Cnt;
            if (x != Nil) {
               bnd.add(x.Car);  // Save old value
               bnd.add(x);  // and symbol
               x.Car = ex.Cdr;  // Set new value
            }
            do {
               y = bnd.Data[--i];
               x = y.Car;
               y.Car = bnd.Data[--i];  // Set new value
               bnd.Data[i] = x;  // Save old value
            } while (i > 0);
            Env.Bind = bnd;
            x = Cdr.prog();
         }
         else {
            int next, argc, j = 0;
            Any arg, args[], av[] = null;
            if (ex.Cdr != Nil) {
               av = new Any[6];
               do
                  av = append(av, j++, (ex = ex.Cdr).Car.eval());
               while (ex.Cdr != Nil);
            }
            next = Env.Next;  Env.Next = 0;
            argc = Env.ArgC;  Env.ArgC = j;
            arg = Env.Arg;    Env.Arg = Nil;
            args = Env.Args;  Env.Args = av;
            i = bnd.Cnt;
            do {
               y = bnd.Data[--i];
               x = y.Car;
               y.Car = bnd.Data[--i];  // Set new value
               bnd.Data[i] = x;  // Save old value
            } while (i > 0);
            Env.Bind = bnd;
            x = Cdr.prog();
            Env.Args = args;
            Env.Arg = arg;
            Env.ArgC = argc;
            Env.Next = next;
         }
         for (i = bnd.Cnt; (i -= 2) >= 0;)
            bnd.Data[i+1].Car = bnd.Data[i];
         Env.Bind = bnd.Link;
         return x;
      }

      final Any apply(Any ex, boolean cf, Any[] v, int n) {
         int i;
         Any x, y;
         Bind bnd = new Bind();  bnd.add(At.Car);  bnd.add(At);
         for (x = Car, i = 0; x instanceof Cell; ++i, x = x.Cdr) {
            bnd.add((y = x.Car).Car);  // Save value
            bnd.add(y);  // and symbol
            y.Car = i >= n? Nil : cf? v[i].Car : v[i];
         }
         if (x == Nil || x != At) {
            if (x != Nil) {
               bnd.add(x.Car);  // Save old value
               bnd.add(x);  // and symbol
               x.Car = Nil;  // Set to NIL
               while (--n >= i)
                  x.Car = new Cell(mkSymbol(cf? v[n].Car : v[n]), x.Car);
            }
            Env.Bind = bnd;
            x = Cdr.prog();
         }
         else {
            int next, argc, j = 0;
            Any arg, args[], av[] = null;
            if (i < n) {
               av = new Any[6];
               do
                  av = append(av, j++, cf? v[i].Car : v[i]);
               while (++i < n);
            }
            next = Env.Next;  Env.Next = 0;
            argc = Env.ArgC;  Env.ArgC = j;
            arg = Env.Arg;    Env.Arg = Nil;
            args = Env.Args;  Env.Args = av;
            Env.Bind = bnd;
            x = Cdr.prog();
            Env.Args = args;
            Env.Arg = arg;
            Env.ArgC = argc;
            Env.Next = next;
         }
         for (i = bnd.Cnt; (i -= 2) >= 0;)
            bnd.Data[i+1].Car = bnd.Data[i];
         Env.Bind = bnd.Link;
         return x;
      }

      final boolean equal(Any x) {
         if (!(x instanceof Cell))
            return false;
         if (!x.Car.equal(Car))
            return false;
         HashSet<Any> mark = new HashSet<Any>();
         Any y = this, a = x, b = y;
         for (;;) {
            if (!(x.Cdr instanceof Cell))
               return x.Cdr.equal(y.Cdr);
            if (!(y.Cdr instanceof Cell))
               return false;
            mark.add(x);  x = x.Cdr;  y = y.Cdr;
            if (mark.contains(x)) {
               for (;;) {
                  if (a == x) {
                     if (b != y)
                        return false;
                     for (;;) {
                        a = a.Cdr;
                        if ((b = b.Cdr) == y)
                           return a == x;
                        if (a == x)
                           return true;
                     }
                  }
                  if (b == y)
                     return false;
                  a = a.Cdr;  b = b.Cdr;
               }
            }
            if (!x.Car.equal(y.Car))
               return false;
         }
      }

      final int compare(Any x) {
         if (x == this)
            return 0;
         if (x == T)
            return -1;
         if (!(x instanceof Cell))
            return +1;
         Any y = this;
         Any a = this;
         Any b = x;
         for (;;) {
            int n;
            if ((n = y.Car.compare(x.Car)) != 0)
               return n;
            if (!((y = y.Cdr) instanceof Cell))
               return y.compare(x.Cdr);
            if (!((x = x.Cdr) instanceof Cell))
               return x == T? -1 : +1;
            if (y == a && x == b)
               return 0;
         }
      }

      final long length() {
         long n = 0;
         HashSet<Any> mark = new HashSet<Any>();
         for (Any x = this;;) {
            ++n;
            mark.add(x);
            if (!((x = x.Cdr) instanceof Cell))
               return n;
            if (mark.contains(x))
               return -1;
         }
      }

      final long size() {
         long n = 0;
         HashSet<Any> mark = new HashSet<Any>();
         for (Any x = this;;) {
            ++n;
            if (x.Car instanceof Cell)
               n += x.Car.size();
            mark.add(x);
            if (!((x = x.Cdr) instanceof Cell) || mark.contains(x))
               return n;
         }
      }

      final InFrame rdOpen(Any ex) {
         try {
            int len = (int)length();
            String[] cmd = new String[len];
            Any x = this;
            for (int i = 0; i < len; ++i) {
               cmd[i] = x.Car.name();
               x = x.Cdr;
            }
            int pid = allocPid();
            return new InFrame(new PicoLispReader((Pids[pid] = Runtime.getRuntime().exec(cmd)).getInputStream(), allocFd(), null, 0), pid);
         }
         catch (IOException e) {
            err(ex, this, "Pipe read open error");
            return null;
         }
      }

      final OutFrame wrOpen(Any ex) {
         try {
            int len = (int)length();
            String[] cmd = new String[len];
            Any x = this;
            for (int i = 0; i < len; ++i) {
               cmd[i] = x.Car.name();
               x = x.Cdr;
            }
            int pid = allocPid();
            return new OutFrame(new PicoLispWriter((Pids[pid] = Runtime.getRuntime().exec(cmd)).getOutputStream(), allocFd()), pid);
         }
         catch (IOException e) {
            err(ex, this, "Pipe write open error");
            return null;
         }
      }

      final String name() {return Car.name() + Cdr.name();}

      final public String toString() {
         Any x, y;
         StringBuilder sb;
         if (Car == Quote  &&  this != Cdr)
            return '\'' + Cdr.toString();
         x = this;
         sb = new StringBuilder();
         sb.append('(');
         if ((y = circ(x)) == null) {
            for (;;) {
               sb.append(x.Car.toString());
               if ((x = x.Cdr) == Nil)
                  break;
               if (!(x instanceof Cell)) {
                  sb.append(" . ");
                  sb.append(x.toString());
                  break;
               }
               sb.append(' ');
            }
         }
         else if (y == x) {
            do {
               sb.append(x.Car.toString());
               sb.append(' ');
            } while (y != (x = x.Cdr));
            sb.append('.');
         }
         else {
            do {
               sb.append(x.Car.toString());
               sb.append(' ');
            } while (y != (x = x.Cdr));
            sb.append(". (");
            do {
               sb.append(x.Car.toString());
               sb.append(' ');
            } while (y != (x = x.Cdr));
            sb.append(".)");
         }
         sb.append(')');
         return sb.toString();
      }
   }
}
