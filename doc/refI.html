<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/1998/REC-html40-19980424/loose.dtd">
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>I</title>
<link rel="stylesheet" href="doc.css" type="text/css">
</head>
<body>

<h1>I</h1>

<dl>

<dt><a name="+Idx"><code>+Idx</code></a>
<dd>Prefix class for maintaining non-unique full-text indexes to <code><a
href="refS.html#+String">+String</a></code> relations, a subclass of <code><a
href="refR.html#+Ref">+Ref</a></code>. Accepts optional arguments for the
minimally indexed substring length (defaults to 3), and a <code><a
href="refH.html#+Hook">+Hook</a></code> attribute. Often used in combination
with the <code><a href="refS.html#+Sn">+Sn</a></code> soundex index, or the
<code><a href="refF.html#+Fold">+Fold</a></code> index prefix classes. See also
<a href="ref.html#dbase">Database</a>.

<pre><code>
(rel nm (+Sn +Idx +String))  # Name
</code></pre>

<dt><a name="+IdxFold"><code>+IdxFold</code></a>
<dd>Prefix class for maintaining non-unique indexes to subsequent substrings of
the <code><a href="refF.html#fold">fold</a></code>ed individual words of
<code><a href="refS.html#+String">+String</a></code> relations. Accepts optional
arguments for the minimally indexed substring length (defaults to 3), and a
<code><a href="refH.html#+Hook">+Hook</a></code> attribute. See also <code><a
href="refI.html#+Idx">+Idx</a></code> and <a href="ref.html#dbase">Database</a>.

<pre><code>
(rel nm (+IdxFold +String))            # Item Description
</code></pre>

<dt><a name="+index"><code>+index</code></a>
<dd>Abstract base class of all database B-Tree index relations (prefix classes
for <code><a href="refR.html#+relation">+relation</a></code>s). The class
hierarchy includes <code><a href="refK.html#+Key">+Key</a></code>, <code><a
href="refR.html#+Ref">+Ref</a></code>, <code><a
href="refI.html#+Idx">+Idx</a></code> and <code><a
href="refI.html#+IdxFold">+IdxFold</a></code>. See also <a
href="ref.html#dbase">Database</a>.

<pre><code>
(isa '+index Rel)  # Check for an index relation
</code></pre>

<dt><a name="id"><code>(id 'num ['num]) -> sym</code></a>
<dt><code>(id 'sym [NIL]) -> num</code>
<dt><code>(id 'sym T) -> (num . num)</code>
<dd>Converts one or two numbers to an external symbol, or an external symbol to
a number or a pair of numbers.

<pre><code>
: (id 7)
-> {7}
: (id 1 2)
-> {2}
: (id '{1-2})
-> 2
: (id '{1-2} T)
-> (1 . 2)
</code></pre>

<dt><a name="idx"><code>(idx 'var 'any 'flg) -> lst<br>
(idx 'var 'any) -> lst<br>
(idx 'var) -> lst</code></a>
<dd>Maintains an index tree in <code>var</code>, and checks for the existence of
<code>any</code>. If <code>any</code> is contained in <code>var</code>, the
corresponding subtree is returned, otherwise <code>NIL</code>. In the first
form, <code>any</code> is destructively inserted into the tree if
<code>flg</code> is non-<code>NIL</code> (and <code>any</code> was not already
there), or deleted from the tree if <code>flg</code> is <code>NIL</code>. The
second form only checks for existence, but does not change the index tree. In
the third form (when called with a single <code>var</code> argument) the
contents of the tree are returned as a sorted list. If all elements are inserted
in sorted order, the tree degenerates into a linear list. See also <code><a
href="refL.html#lup">lup</a></code>, <code><a
href="refH.html#hash">hash</a></code>, <code><a
href="refD.html#depth">depth</a></code>, <code><a
href="refS.html#sort">sort</a></code>, <code><a
href="refB.html#balance">balance</a></code> and <code><a
href="refM.html#member">member</a></code>.

<pre><code>
: (idx 'X 'd T)                              # Insert data
-> NIL
: (idx 'X 2 T)
-> NIL
: (idx 'X '(a b c) T)
-> NIL
: (idx 'X 17 T)
-> NIL
: (idx 'X 'A T)
-> NIL
: (idx 'X 'd T)
-> (d (2 NIL 17 NIL A) (a b c))              # 'd' already existed
: (idx 'X T T)
-> NIL
: X                                          # View the index tree
-> (d (2 NIL 17 NIL A) (a b c) NIL T)
: (idx 'X 'A)                                # Check for 'A'
-> (A)
: (idx 'X 'B)                                # Check for 'B'
-> NIL
: (idx 'X)
-> (2 17 A d (a b c) T)                      # Get list
: (idx 'X 17 NIL)                            # Delete '17'
-> (17 NIL A)
: X
-> (d (2 NIL A) (a b c) NIL T)               # View it again
: (idx 'X)
-> (2 A d (a b c) T)                         # '17' is deleted
</code></pre>

<dt><a name="if"><code>(if 'any1 any2 . prg) -> any</code></a>
<dd>Conditional execution: If the condition <code>any1</code> evaluates to
non-<code>NIL</code>, <code>any2</code> is evaluated and returned. Otherwise,
<code>prg</code> is executed and the result returned. See also <code><a
href="refC.html#cond">cond</a></code>, <code><a
href="refW.html#when">when</a></code> and <code><a
href="refI.html#if2">if2</a></code>.

<pre><code>
: (if (> 4 3) (println 'OK) (println 'Bad))
OK
-> OK
: (if (> 3 4) (println 'OK) (println 'Bad))
Bad
-> Bad
</code></pre>

<dt><a name="if2"><code>(if2 'any1 'any2 any3 any4 any5 . prg) -> any</code></a>
<dd>Four-way conditional execution for two conditions: If both conditions
<code>any1</code> and <code>any2</code> evaluate to non-<code>NIL</code>,
<code>any3</code> is evaluated and returned. Otherwise, <code>any4</code> or
<code>any5</code> is evaluated and returned if <code>any1</code> or
<code>any2</code> evaluate to non-<code>NIL</code>, respectively. If none of the
conditions evaluate to non-<code>NIL</code>, <code>prg</code> is executed and
the result returned. See also <code><a href="refI.html#if">if</a></code> and
<code><a href="refC.html#cond">cond</a></code>.

<pre><code>
: (if2 T T 'both 'first 'second 'none)
-> both
: (if2 T NIL 'both 'first 'second 'none)
-> first
: (if2 NIL T 'both 'first 'second 'none)
-> second
: (if2 NIL NIL 'both 'first 'second 'none)
-> none
</code></pre>

<dt><a name="ifn"><code>(ifn 'any1 any2 . prg) -> any</code></a>
<dd>Conditional execution ("If not"): If the condition <code>any1</code>
evaluates to <code>NIL</code>, <code>any2</code> is evaluated and returned.
Otherwise, <code>prg</code> is executed and the result returned.

<pre><code>
: (ifn (= 3 4) (println 'OK) (println 'Bad))
OK
-> OK
</code></pre>

<dt><a name="import"><code>(import . lst) -> NIL</code></a>
<dd>Wrapper function for <code><a href="refI.html#intern">intern</a></code>.
Typically used to import symbols from other namespaces, as created by <code><a
href="refS.html#symbols">symbols</a></code>. <code>lst</code> should be a list
of symbols. An import conflict error is issued when a symbol with the same name
already exists in the current namespace. See also <code><a
href="refP.html#pico">pico</a></code> and <code><a
href="refL.html#local">local</a></code>.

<pre><code>
: (import libA~foo libB~bar)
-> NIL
</code></pre>

<dt><a name="in"><code>(in 'any . prg) -> any</code></a>
<dd>Opens <code>any</code> as input channel during the execution of
<code>prg</code>. The current input channel will be saved and restored
appropriately. If the argument is <code>NIL</code>, standard input is used. If
the argument is a symbol, it is used as a file name (opened for reading
<i>and</i> writing if the first character is "<code>+</code>"). If it is a
positive number, it is used as the descriptor of an open file. If it is a
negative number, the saved input channel such many levels above the current one
is used. Otherwise (if it is a list), it is taken as a command with arguments,
and a pipe is opened for input. See also <code><a
href="refI.html#ipid">ipid</a></code>, <code><a
href="refC.html#call">call</a></code>, <code><a
href="refL.html#load">load</a></code>, <code><a
href="refF.html#file">file</a></code>, <code><a
href="refO.html#out">out</a></code>, <code><a
href="refE.html#err">err</a></code>, <code><a
href="refP.html#poll">poll</a></code>, <code><a
href="refP.html#pipe">pipe</a></code> and <code><a
href="refC.html#ctl">ctl</a></code>.

<pre><code>
: (in "a" (list (read) (read) (read)))  # Read three items from file "a"
-> (123 (a b c) def)

: (in '(file "-b" "--mime" "bin/picolisp")  # Get the mime type
   (line T) )
-> "application/x-executable; charset=binary"
</code></pre>

<dt><a name="inc"><code>(inc 'num) -> num<br>
(inc 'var ['num]) -> num</code></a>
<dd>The first form returns the value of <code>num</code> incremented by 1. The
second form increments the <code>VAL</code> of <code>var</code> by 1, or by
<code>num</code>. If the first argument is <code>NIL</code>, it is returned
immediately. <code>(inc Num)</code> is equivalent to <code>(+ Num 1)</code> and
<code>(inc 'Var)</code> is equivalent to <code>(set 'Var (+ Var 1))</code>. See
also <code><a href="refD.html#dec">dec</a></code> and <code><a
href="ref_.html#+">+</a></code>.

<pre><code>
: (inc 7)
-> 8
: (inc -1)
-> 0
: (zero N)
-> 0
: (inc 'N)
-> 1
: (inc 'N 7)
-> 8
: N
-> 8

: (setq L (1 2 3 4))
-> (1 2 3 4)
: (inc (cdr L))
-> 3
: L
-> (1 3 3 4)
</code></pre>

<dt><a name="inc!"><code>(inc! 'obj 'sym ['num]) -> num</code></a>
<dd><a href="ref.html#trans">Transaction</a> wrapper function for <code><a
href="refI.html#inc">inc</a></code>. <code>num</code> defaults to 1. Note that
for incrementing a property value of an entity typically the <code><a
href="refE.html#entityMesssages">inc!></a></code> message is used. See also
<code><a href="refN.html#new!">new!</a></code>, <code><a
href="refR.html#request!">request!</a></code>, <code><a
href="refS.html#set!">set!</a></code> and <code><a
href="refP.html#put!">put!</a></code>.

<pre><code>
(inc! Obj 'cnt 0)  # Incrementing a property of a non-entity object
</code></pre>

<dt><a name="index"><code>(index 'any 'lst) -> cnt | NIL</code></a>
<dd>Returns the <code>cnt</code> position of <code>any</code> in
<code>lst</code>, or <code>NIL</code> if it is not found. See also <code><a
href="refO.html#offset">offset</a></code> and <code><a
href="refS.html#sub?">sub?</a></code>.

<pre><code>
: (index 'c '(a b c d e f))
-> 3
: (index '(5 6) '((1 2) (3 4) (5 6) (7 8)))
-> 3
</code></pre>

<dt><a name="info"><code>(info 'any ['flg]) -> (cnt|flg dat . tim)</code></a>
<dd>Returns information about a file with the name <code>any</code>: The current
size <code>cnt</code> in bytes, and the modification date and time (UTC). For
directories, <code>T</code> is returned instead of the size, and
<code>NIL</code> for other non-regular files. If <code>flg</code> is
non-<code>NIL</code> and <code>any</code> is the name of a symbolic link, then
the link itself is used, not the file that it refers to. See also <code><a
href="refD.html#dir">dir</a></code>, <code><a
href="refD.html#date">date</a></code>, <code><a
href="refT.html#time">time</a></code> and <code><a
href="refL.html#lines">lines</a></code>.

<pre><code>
$ ls -l x.l
-rw-r--r--   1 abu      users         208 Jun 17 08:58 x.l
$ pil +
: (info "x.l")
-> (208 730594 . 32315)
: (stamp 730594 32315)
-> "2000-06-17 08:58:35"
</code></pre>

<dt><a name="init"><code>(init 'tree ['any1] ['any2]) -> lst</code></a>
<dd>Initializes a structure for stepping iteratively through a database tree.
<code>any1</code> and <code>any2</code> may specify a range of keys. If
<code>any2</code> is greater than <code>any1</code>, the traversal will be in
opposite direction. See also <code><a href="refT.html#tree">tree</a></code>,
<code><a href="refS.html#step">step</a></code>, <code><a
href="refI.html#iter">iter</a></code> and <code><a
href="refS.html#scan">scan</a></code>.

<pre><code>
: (init (tree 'nr '+Item) 3 5)
-> (((3 . 5) ((3 NIL . {3-3}) (4 NIL . {3-4}) (5 NIL . {3-5}) (6 NIL . {3-6}) (7 NIL . {3-8}))))
</code></pre>

<dt><a name="insert"><code>(insert 'cnt 'lst 'any) -> lst</code></a>
<dd>Inserts <code>any</code> into <code>lst</code> at position <code>cnt</code>.
This is a non-destructive operation. See also <code><a
href="refR.html#remove">remove</a></code>, <code><a
href="refP.html#place">place</a></code>, <code><a
href="refA.html#append">append</a></code>, <code><a
href="refD.html#delete">delete</a></code> and <code><a
href="refR.html#replace">replace</a></code>.

<pre><code>
: (insert 3 '(a b c d e) 777)
-> (a b 777 c d e)
: (insert 1 '(a b c d e) 777)
-> (777 a b c d e)
: (insert 9 '(a b c d e) 777)
-> (a b c d e 777)
</code></pre>

<dt><a name="intern"><code>(intern 'sym) -> sym</code></a>
<dd>Creates or finds an internal symbol. If a symbol with the name
<code>sym</code> is already intern, it is returned. Otherwise, <code>sym</code>
is interned and returned. See also <code><a
href="refS.html#symbols">symbols</a></code>, <code><a
href="refZ.html#zap">zap</a></code>, <code><a
href="refE.html#extern">extern</a></code> and <code><a
href="ref_.html#====">====</a></code>.

<pre><code>
: (intern "abc")
-> abc
: (intern 'car)
-> car
: ((intern (pack "c" "a" "r")) (1 2 3))
-> 1
</code></pre>

<dt><a name="ipid"><code>(ipid) -> pid | NIL</code></a>
<dd>Returns the corresponding process ID when the current input channel is
reading from a pipe, otherwise <code>NIL</code>. See also <code><a
href="refO.html#opid">opid</a></code>, <code><a
href="refI.html#in">in</a></code>, <code><a
href="refP.html#pipe">pipe</a></code> and <code><a
href="refL.html#load">load</a></code>.

<pre><code>
: (in '(ls "-l") (println (line T)) (kill (ipid)))
"total 7364"
-> T
</code></pre>

<dt><a name="isa"><code>(isa 'cls|typ 'obj) -> obj | NIL</code></a>
<dd>Returns <code>obj</code> when it is an object that inherits from
<code>cls</code> or <code>type</code>. See also <a href="ref.html#oop">OO
Concepts</a>, <code><a href="refC.html#class">class</a></code>, <code><a
href="refT.html#type">type</a></code>, <code><a
href="refN.html#new">new</a></code> and <code><a
href="refO.html#object">object</a></code>.

<pre><code>
: (isa '+Address Obj)
-> {1-17}
: (isa '(+Male +Person) Obj)
-> NIL
</code></pre>

<dt><a name="isa/2"><code>isa/2</code></a>
<dd><a href="ref.html#pilog">Pilog</a> predicate that succeeds if the second
argument is of the type or class given by the first argument, according to the
<code><a href="refI.html#isa">isa</a></code> function. Typically used in
<code><a href="refD.html#db/3">db/3</a></code> or <code><a
href="refS.html#select/3">select/3</a></code> database queries. See also
<code><a href="refS.html#same/3">same/3</a></code>, <code><a
href="refB.html#bool/3">bool/3</a></code>, <code><a
href="refR.html#range/3">range/3</a></code>, <code><a
href="refH.html#head/3">head/3</a></code>, <code><a
href="refF.html#fold/3">fold/3</a></code>, <code><a
href="refP.html#part/3">part/3</a></code> and <code><a
href="refT.html#tolr/3">tolr/3</a></code>.

<pre><code>
: (? (db nm +Person @Prs) (isa +Woman @Prs) (val @Nm @Prs nm))
 @Prs={2-Y} @Nm="Alexandra of Denmark"
 @Prs={2-1I} @Nm="Alice Maud Mary"
 @Prs={2-F} @Nm="Anne"
 @Prs={2-j} @Nm="Augusta Victoria".   # Stop
</code></pre>

<dt><a name="iter"><code>(iter 'tree ['fun] ['any1] ['any2] ['flg])</code></a>
<dd>Iterates through a database tree by applying <code>fun</code> to all values.
<code>fun</code> defaults to <code><a
href="refP.html#println">println</a></code>. <code>any1</code> and
<code>any2</code> may specify a range of keys. If <code>any2</code> is greater
than <code>any1</code>, the traversal will be in opposite direction. Note that
the keys need not to be atomic, depending on the application's index structure.
If <code>flg</code> is non-<code>NIL</code>, partial keys are skipped. See also
<code><a href="refT.html#tree">tree</a></code>, <code><a
href="refU.html#ubIter">ubIter</a></code>, <code><a
href="refS.html#scan">scan</a></code>, <code><a
href="refI.html#init">init</a></code> and <code><a
href="refS.html#step">step</a></code>.

<pre><code>
: (iter (tree 'nr '+Item))
{3-1}
{3-2}
{3-3}
{3-4}
{3-5}
{3-6}
{3-8}
-> {7-1}
: (iter (tree 'nr '+Item) '((This) (println (: nm))))
"Main Part"
"Spare Part"
"Auxiliary Construction"
"Enhancement Additive"
"Metal Fittings"
"Gadget Appliance"
"Testartikel"
-> {7-1}
</code></pre>

</dl>

</body>
</html>
