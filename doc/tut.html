<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Pico Lisp Tutorial</title>
<link rel="stylesheet" href="doc.css" type="text/css">
</head>
<body>
<a href="mailto:abu@software-lab.de">abu@software-lab.de</a>

<h1>A Pico Lisp Tutorial</h1>

<p align=right>(c) Software Lab. Alexander Burger

<p>This document demonstrates some aspects of the Pico Lisp system in detail and
example. For a general description of the Pico Lisp kernel please look at the <a
href="ref.html">Pico Lisp Reference</a>.

<p>This is <i>not</i> a Lisp tutorial, as it assumes some working knowledge of
Lisp (and programming in general). It concentrates on the specialties of Pico
Lisp, and its differences to other Lisp dialects.

<p>If not stated otherwise, all examples assume that Pico Lisp was started from
the shell prompt as

<p><pre><code>
$ ./p dbg.l
:
</code></pre>

<p>This loads the Pico Lisp base system and the debugging environment, and waits
for you to enter input lines at the interpreter prompt (<code>:</code>). You can
terminate the interpreter and return to the shell at any time, by either hitting
the <code>RETURN</code> key (i.e. by entering an empty line), or by executing
the function <code><a href="ref.html#bye">(bye)</a></code>.

<p>It is very helpful - though not absolutely necessary - when you know how to
use the <code>vi</code> editor.

<p>We notice that some people try to use Emacs - or some other IDE - as a
frontend to the Pico Lisp console. This is not recommended, because the Pico
Lisp debugging environment will set the console (tty) to raw mode by itself and
do some special handling during character input.

<p>If you feel that you absolutely have to use an input frontend, please remove
the entry "@lib/led.l" from "dbg.l". Note that in this case, however, you will
not have the <code>TAB</code> symbol expansion feature available during command
line editing.

<p>We recommend that you have a terminal window open, and try the examples by
yourself. You may either type them in, directly to the Pico Lisp interpreter, or
edit a separate source file (e.g. <code>"test.l"</code>) in a second terminal
window and load it into Pico Lisp with

<p><pre><code>
: (load "test.l")
</code></pre>

<p>each time you have modified and saved it.


<p>If you are new to Pico Lisp, you might want to read the following sections in
the given order, as some of them assume knowledge about previous ones. Otherwise
just jump anywhere you are interested in.

<p><ul>
<li><a href="#ledit">Command Line Editing</a>
<li><a href="#brw">Browsing</a>
<li><a href="#fun">Defining Functions</a>
<li><a href="#dbg">Debugging</a>
<li><a href="#funio">Functional I/O</a>
<li><a href="#script">Scripting</a>
<li><a href="#oop">Objects and Classes</a>
<li><a href="#ext">Persistence (External Symbols)</a>
<li><a href="#db">Database Programming</a>
<li><a href="#gui">User Interface (GUI) Programming</a>
<li><a href="#pilog">Pilog -- Pico Lisp Prolog</a>
<li><a href="#sql">Poor Man's SQL</a>
<li><a href="#ref">References</a>
</ul>


<p><hr>
<h2><a name="ledit">Command Line Editing</a></h2>

<p>Pico Lisp permanently reads input from the current input channel (i.e. the
console in interactive mode), evaluates it, and prints the result to the current
output channel.

<p>To alleviate the task of manual line input, a command line editor is provided
which is similar to (though much simpler than) the <code>readline</code> feature
of the <code>bash</code> shell. Only a subset of the <code>vi</code> mode is
supported, which is restricted to single-key commands (the "real"
<code>vi</code> supports multi-key commands and the modification of most
commands with count prefixes). It is loaded at startup via "dbg.l", you find its
source in "lib/led.l" if wish to take a look.

<p>You can enter lines in the normal way, correcting mistypes with the
<code>BACKSPACE</code> key, and terminating them with the <code>RETURN</code>
key. This is the <i>Insert Mode</i>.

<p>If you hit <code>ESC</code>, you get into <i>Command Mode</i>. Now you can
navigate horizontally in the current input line, or vertically in the history of
previously entered lines, with key commands borrowed from the <code>vi</code>
editor. Note, however, that there is always only a single line visible.

<p>Let's say you did some calculation

<p><pre><code>
: (* (+ 2 3) (- 7 2))
-> 25
:
</code></pre>

<p>If you want to repeat a modified version of this command, using
<code>8</code> instead of <code>7</code>, you don't have to re-type the
whole command, but type

<p><ul>
<li><code>ESC</code> to get into <i>Command Mode</i>
<li><code>k</code> to get one line "up"
<li><code>f</code> and <code>7</code> to "find" the character <code>7</code>
<li><code>r</code> and <code>8</code> to "replace" with <code>8</code>
</ul>

<p>Then you hit <code>RETURN</code> to execute the modified line. Instead of
jumping to the <code>7</code> with the "find" command, you may also type
<code>l</code> (move "right") repeatedly till you reach the correct position.

<p>The key commands in the <i>Command Mode</i> are listed below. Some commands
change the mode back to <i>Insert Mode</i> as indicated in parentheses. Commands
which operate on a "word" take either the current atom (number or symbol), or a
whole expression when the cursor is at a left parenthesis.

<p><ul>
<li><code>k</code> - Go up one line
<li><code>j</code> - Go down one line
<li><code>l</code> - Go right one character
<li><code>h</code> - Go left one character
<li><code>w</code> - Go right one word
<li><code>b</code> - Go back (left) one word
<li><code>0</code> - Go to the beginning of the line
<li><code>$</code> - Go to the end of the line
<li><code>i</code> - Enter <i>Insert Mode</i> at the cursor position
<li><code>a</code> - Append (<i>Insert Mode</i>) after the cursor position
<li><code>A</code> - Append (<i>Insert Mode</i>) at the end of the line
<li><code>I</code> - Insert (<i>Insert Mode</i>) at the beginning of the line
<li><code>x</code> - Delete the character at the cursor position
<li><code>X</code> - Delete the character left of the cursor position
<li><code>r</code> - Replace the character at the cursor position with the next key
<li><code>s</code> - Substitute the character at the cursor position (<i>Insert Mode</i>)
<li><code>S</code> - Substitute the whole line (<i>Insert Mode</i>)
<li><code>d</code> - Delete the word at the cursor position (<i>Insert Mode</i>)
<li><code>D</code> - Delete the rest of the line
<li><code>c</code> - Change the word at the cursor position (<i>Insert Mode</i>)
<li><code>C</code> - Change the rest of the line (<i>Insert Mode</i>)
<li><code>f</code> - Find next key in the rest of the current line
<li><code>p</code> - Paste data deleted with <code>x</code>, <code>X</code>, <code>d</code> or <code>D</code> after the cursor position
<li><code>P</code> - Paste data deleted with <code>x</code>, <code>X</code>, <code>d</code> or <code>D</code> before the cursor position
<li><code>/</code> - Accept an input pattern and search the history for it
<li><code>n</code> - Search for next occurrence of pattern (as entered with <code>/</code>)
<li><code>N</code> - Search for previous occurrence of pattern
<li><code>%</code> - Show matching parenthesis
<li><code>~</code> - Convert character to opposite (lower or upper) case and move right
<li><code>u</code> - Undo the last change (one level only)
<li><code>U</code> - Undo all changes of the current line
<li><code>g</code> - Display current contents of cut buffer (not in <code>vi</code>)
</ul>

<p>Notes:
<ul>

<li>The <code>d</code> command corresponds to the <code>dw</code> command of the
<code>vi</code> editor, and <code>c</code> corresponds to <code>cw</code>.

<li>Search patterns may contain "<code>@</code>" characters as wildcards.

<li>Lines shorter than 3 characters, lines beginning with a space character, or
duplicate lines are not entered into the history.

<li>The history is stored in a file named ".picoHistory" in the Pico Lisp home
directory. The length of the history is limited to 4000 lines.

</ul>

<p>The key combination <code>Ctrl-X</code> is useful when the program stopped at
a breakpoint, or after program execution was interrupted with
<code>Ctrl-C</code>, to abandon all further processing and return to the
interpreter's top level. This is equivalent to invoking <code><a
href="ref.html#quit">quit</a></code>.

<p>In <i>Input Mode</i>, only the following keys have a special meaning:

<p><ul>

<li><code>BACKSPACE</code> (<code>Ctrl-H</code>) and <code>DEL</code> erase the
character to the left

<li><code>Ctrl-V</code> inserts the next key literally

<li><code>TAB</code> performs symbol expansion: When a symbol name is entered
partially and <code>TAB</code> is pressed subsequently, all internal symbols
matching the partial input are shown in sequence.

<li><code>ESC</code> terminates <i>Input Mode</i> and enters <i>Command Mode</i>

</ul>

<p>Please take some time to experiment and to get used to command line editing.
It will make life much easier in the future :-)


<p><hr>
<h2><a name="brw">Browsing</a></h2>

<p>Pico Lisp provides some functionality for inspecting pieces of data and code
within the running system.

<p>Most commonly used is probably the <code>show</code> function. It takes a
symbolic argument, and shows the symbol's name (if any), followed by its value
cell, and then the contents of the property list on the following lines.

<p><pre><code>
: (setq A '(This is the value))  # Set the value cell of 'A'
-> (This is the value)
: (put 'A 'key1 'val1)           # Store property 'key1'
-> val1
: (put 'A 'key2 'val2)           # and 'key2'
-> val2
: (show 'A)                      # Now 'show' the symbol 'A'
A (This is the value)
   key2 val2
   key1 val1
-> A
</code></pre>

<p><code>show</code> accepts an arbitrary number of arguments which are
processed according to the rules of <code><a href="ref.html#get">get</a></code>,
resulting in a symbol which is showed then.

<p><pre><code>
: (put 'B 'a 'A)        # Put 'A' under the 'a'-property of 'B'
-> A
: (setq Lst '(A B C))   # Create a list with 'B' as second argument
-> (A B C)
: (show Lst 2 'a)       # Show the property 'a of the 2nd element of 'Lst'
A (This is the value)   # (which is 'A' again)
   key2 val2
   key1 val1
-> A
</code></pre>

<p>Similar to <code>show</code> is <code>edit</code>. It takes an arbitrary
number of symbolic arguments, writes them to a temporary file in a format
similar to <code>show</code>, and starts the <code>vim</code> editor with that
file.

<p><pre><code>
: (edit 'A 'B)
</code></pre>

<p>The <code>vim</code> window will look like

<p><pre><code>
A (This is the value)
key1 val111
key2 val2

(********)

B NIL
a A  # (This is the value)

(********)
</code></pre>

<p>Now you can modify values or properties. You should not touch the
parenthesized asterisks, as they serve as delimiters. If you position the cursor
on the first char of a symbol name and type '<code>K</code>' ("Keyword lookup"),
the editor will be restarted with that symbol added to the editor window.
'<code>Q</code>' (for "quit") will bring you back to the previous view.

<p><code>edit</code> is also very useful to browse in a database. You can follow
the links between objects with '<code>K</code>', and even - e.g. for low-level
repairs - modify the data (but only if you are really sure about what you are
doing, and don't forget to <code><a href="ref.html#commit">commit</a></code>
when you are done).

<p><code>more</code> is a simple tool that displays the elements of a list one
by one. It stops after each element and waits for input. If you just hit
<code>RETURN</code>, <code>more</code> continues with the next element,
otherwise (usually I type a dot (<code>.</code>) followed by
<code>RETURN</code>) it terminates.

<p><pre><code>
: (more (1 2 3 4 5 6))
1                          # Hit RETURN
2.                         # Hit '.' and RETURN
-> T                       # stopped
</code></pre>

<p>Optionally <code>more</code> takes a function as a second argument and
applies that function to each element (instead of the default <code><a
href="ref.html#print">print</a></code>). Here, often <code>show</code> or
<code>pp</code> (see below) is used.

<p><pre><code>
: (more '(A B))            # Step through 'A' and 'B'
A
B-> T
: (more '(A B) show)       # Step through 'A' and 'B' with 'show'
A (This is the value)      # showing 'A'
   key2 val2
   key1 val111
                           # Hit RETURN
B NIL                      # showing 'B'
   a A
-> T
</code></pre>

<p>The <i>pretty-print</i> function <code>pp</code> takes a symbol that has a
function defined (or two symbols that specify message and class for a method
definition), and displays that definition in a formatted and indented way.

<p><pre><code>
: (pp 'pretty)
(de pretty (X N . @)
   (setq N (abs (space (or N 0))))
   (while (args) (printsp (next)))
   (if (or (atom X) (>= 12 (size X)))
      (print X)
      (while (== 'quote (car X))
         (prin "'")
         (pop 'X) )
      (let Z X
         (prin "(")
         (when (memq (print (pop 'X)) *PP)
            (cond
               ((memq (car Z) *PP1)
                  (if (and (pair (car X)) (pair (cdar X)))
                     (when (>= 12 (size (car X)))
                        (space)
                        (print (pop 'X)) )
                     (space)
                     (print (pop 'X))
                     (when
                        (or
                           (atom (car X))
                           (>= 12 (size (car X))) )
                        (space)
                        (print (pop 'X)) ) ) )
               ((memq (car Z) *PP2)
                  (inc 'N 3)
                  (loop
                     (prinl)
                     (pretty (cadr X) N (car X))
                     (NIL (setq X (cddr X))) ) )
               ((or (atom (car X)) (>= 12 (size (car X))))
                  (space)
                  (print (pop 'X)) ) ) )
         (when X
            (loop
               (T (== Z X) (prin " ."))
               (T (atom X) (prin " . ") (print X))
               (prinl)
               (pretty (pop 'X) (+ 3 N))
               (NIL X) )
            (space) )
         (prin ")") ) ) )
-> pretty
</code></pre>

<p>The style is the same as we use in all our source files:
<ul>

<li>The Indentation level is three spaces

<li>If a list is too long, pretty-print the <code>CAR</code> on the current
line, and each element of the <code>CDR</code> recursively on its own line.

<li>A closing parenthesis a preceded by a space if the corresponding open
parenthesis is not on the same line

</ul>

<p>The <code>what</code> function returns a list of all internal symbols in the
system. If an optional pattern argument (with '<code>@</code>' wildcard
characters ) is given, only symbols matching that pattern are returned.

<p><pre><code>
: (what "prin@")
-> (println printsp print> prinl print prin)
</code></pre>

<p>The function <code>who</code> returns <i>"who contains that"</i>, i.e. a list
of symbols that contain a given argument somewhere in their value or property
list.

<p><pre><code>
: (who 'print)
-> ((print> . +Relation) query show select pretty "edit" msg rules pp more (print> . +Date))
</code></pre>

<p>A dotted pair indicates either a method definition or a property entry. So
<code>(print> . +Relation)</code> denotes the <code>print&gt;</code> method of
the <code>+Relation</code> class.

<p><code>who</code> can be conveniently combined with <code>more</code> and
<code>pp</code>:

<p><pre><code>
: (more (who 'print) pp)
(dm (print> . +Relation) (Val)   # Pretty-print these functions one by one
   (print Val) )

(de query ("Q" "Dbg")
   ...
</code></pre>

<p>The argument to <code>who</code> may also be a pattern list (see <code><a
href="ref.html#match">match</a></code>):

<p><pre><code>
: (who '(print @ (val @)))
-> (show)
: (more (who '(+ @ 1)) pp)
(de _week (Dat)
   (/ (- Dat (% (+ Dat 1) 7)) 7) )
   ...
</code></pre>

<p>The function <code>can</code> returns a list which indicates which classes
<i>can</i> accept a given message. Again, this list is suitable for iteration
with <code>pp</code>:

<p><pre><code>
: (can 'del>)                                   # Which classes accept 'del>' ?
-> ((del> . +Relation) (del> . +Entity) (del> . +List))
: (more (can 'del>) pp)                         # Inspect the methods with 'pp'
(dm (del> . +Relation) (Obj Old Val)
   (and (&lt;> Old Val) Val) )

(dm (del> . +Entity) (Var Val)
   (when
      (and
         Val
         (has> (meta This Var) Val (get This Var)) )
      (let Old (get This Var)
         (rel>
            (meta This Var)
            This
            Old
            (put This Var (del> (meta This Var) This Old @)) )
         (upd> This Var Old) ) ) )

(dm (del> . +List) (Obj Old Val)
   (and (&lt;> Old Val) (delete Val Old)) )
</code></pre>

<p><code>dep</code> shows the dependencies in a class hierarchy. That is, for a
given class it displays the tree of its (super)class(es) above it, and the tree
of its subclasses below it.

<p>To view the complete hierarchy of input fields, we start with the root class
<code>+Relation</code>:

<p><pre><code>
: (dep '+Relation)
+Relation
   +Number
      +Time
      +Date
   +Symbol
      +String
   +Blob
   +Link
      +Joint
   +Bool
   +Any
   +Bag
-> +Relation
</code></pre>

<p>If we are interested in <code>+Link</code>:

<p><pre><code>
: (dep '+Link)
   +Relation
+Link
   +Joint
-> +Link
</code></pre>

<p>This says that <code>+Link</code> is a subclass of <code>+Relation</code>,
and has a single subclass (<code>+Joint</code>).


<p><hr>
<h2><a name="fun">Defining Functions</a></h2>

<p>Most of the time during programming is spent defining functions (or methods).
In the following we will concentrate on functions, but most will be true for
methods as well except for using <code>dm</code> instead of <code>de</code>.

<p>The notorious "Hello world" function must be defined:

<p><pre><code>
: (de hello ()
   (prinl "Hello world") )
-> hello
</code></pre>

<p>The <code>()</code> in the first line indicates a function without arguments.
The body of the function is in the second line, consisting of a single
statement. The last line is the return value of <code>de</code>. From now on we
will omit the return values of examples when they are unimportant.

<p>You'll know that you can call this function as

<p><pre><code>
: (hello)
Hello world
</code></pre>

<p>A function with an argument might look this way:

<p><pre><code>
: (de hello (X)
   (prinl "Hello " X) )
hello redefined
</code></pre>

<p>Pico Lisp informs you that you have just redefined the function. This might
be a useful warning in case you forgot that a bound symbol with that name
already existed.

<p><pre><code>
: (hello "world")
Hello world
</code></pre>

<p><pre><code>
: (hello "Alex")
Hello Alex
</code></pre>

<p>Normally, Pico Lisp evaluates the arguments before it passes them to a
function:

<p><pre><code>
: (hello (+ 1 2 3))
Hello 6
</code></pre>

<p><pre><code>
: (setq A 1  B 2)       # Set 'A' to 1 and 'B' to 2
-> 2
: (de foo (X Y)         # 'foo' returns the list of its arguments
   (list X Y) )
-> foo
: (foo A B)             # Now call 'foo' with 'A' and 'B'
-> (1 2)                # -> We get a list of 1 and 2, the values of 'A' and 'B'
</code></pre>

<p>In some cases you don't want that. For some functions (<code><a
href="ref.html#setq">setq</a></code> for example) it is better if the function
gets all arguments unevaluated, and can decide for itself what to do with them.

<p>For such cases you do not define the function with a <i>list</i> of
parameters, but give it a <i>single atomic</i> parameter instead. Pico Lisp will
then bind all (unevaluated) arguments to that list.

<p><pre><code>
: (de foo X
   (list (car X) (cadr X)) )        # 'foo' lists the first two arguments

: (foo A B)                         # Now call it again
-> (A B)                            # -> We don't get '(1 2)', but '(A B)'

: (de foo X
   (list (car X) (eval (cadr X))) ) # Now evaluate only the second argument

: (foo A B)
-> (A 2)                            # -> We get '(A 2)'
</code></pre>

<p>As a logical consequence, you can combine these principles. To define a
function with 2 evaluated and an arbitrary number of unevaluated arguments:

<p><pre><code>
: (de foo (X Y . Z)     # Evaluate only the first two args
   (list X Y Z) )

: (foo A B C D E)
-> (1 2 (C D E))        # -> Get the value of 'A' and 'B' and the remaining list
</code></pre>

<p>More common, in fact, is the case where you want to pass an arbitrary number
of <i>evaluated</i> arguments to a function. For that, Pico Lisp recognizes the
symbol <code>@</code> as a single atomic parameter and remembers all evaluated
arguments in an internal frame. This frame can then be accessed sequentially
with the <code><a href="ref.html#args">args</a></code>, <code><a
href="ref.html#next">next</a></code>, <code><a
href="ref.html#arg">arg</a></code> and <code><a
href="ref.html#rest">rest</a></code> functions.

<p><pre><code>
: (de foo @
   (list (next) (next)) )     # Get the first two arguments

: (foo A B)
-> (1 2)
</code></pre>

<p>Again, this can be combined:

<p><pre><code>
: (de foo (X Y . @)
   (list X Y (next) (next)) ) # 'X' and 'Y' are fixed arguments

: (foo A B (+ 3 4) (* 3 4))
-> (1 2 7 12)                 # All arguments are evaluated
</code></pre>

<p>These examples are not very useful, because the advantage of a variable
number of arguments is not used. A function that prints all its evaluated
numeric arguments, each on a line followed by its squared value:

<p><pre><code>
: (de foo @
   (while (args)
      (println (next) (* (arg) (arg))) ) )

: (foo (+ 2 3) (- 7 1) 1234 (* 9 9))
5 25
6 36
1234 1522756
81 6561
-> 6561
</code></pre>

<p>Finally, it is possible to pass all these evaluated argument to another
function, using <code><a href="ref.html#pass">pass</a></code>:

<p><pre><code>
: (de foo @
   (pass println 9 8 7)       # First print all arguments preceded by 9, 8, 7
   (pass + 9 8 7) )           # Then add all these values

: (foo (+ 2 3) (- 7 1) 1234 (* 9 9))
9 8 7 5 6 1234 81             # Printing ...
-> 1350                       # Return the result
</code></pre>


<p><hr>
<h2><a name="dbg">Debugging</a></h2>

<p>There are two major ways to debug functions (and methods) at runtime:
<i>Tracing</i> and <i>single-stepping</i>.

<p><i>Tracing</i> means letting functions of interest print their name and arguments
when they are entered, and their name again and the return value when they are
exited.

<p>For demonstration, let's define the unavoidable factorial function (or just
<code><a href="ref.html#load">load</a></code> the file "<code><a
href="fun.l">doc/fun.l</a></code>"):

<p><pre><code>
(de fact (N)
   (if (=0 N)
      1
      (* N (fact (- N 1))) ) )
</code></pre>

<p>With <code><a href="ref.html#trace">trace</a></code> we can put it in trace
mode:

<p><pre><code>
: (trace 'fact)
-> fact
</code></pre>

<p>Calling <code>fact</code> now will display its execution trace.

<p><pre><code>
: (fact 3)
 fact : 3
  fact : 2
   fact : 1
    fact : 0
    fact = 1
   fact = 1
  fact = 2
 fact = 6
-> 6
</code></pre>

<p>As can be seen here, each level of function call will indent by an additional
space. Upon function entry, the name is separated from the arguments with a
colon (<code>:</code>), and upon function exit with an equals sign
(<code>=</code>) from the return value.

<p>Trace works by modifying the function body, so generally only for functions
defined as lists (lambda expressions, see <a href="ref.html#ev">Evaluation</a>).
Tracing a <code>C</code>-function is possible, however, when it is a function
that evaluates all its arguments.

<p>So let's trace the functions <code><a href="ref.html#=0">=0</a></code> and
<code><a href="ref.html#*">*</a></code>:

<p><pre><code>
: (trace '=0)
-> =0
: (trace '*)
-> *
</code></pre>

<p>If we call <code>fact</code> again, we see the additional output:

<p><pre><code>
: (fact 3)
 fact : 3
  =0 : 3
  =0 = NIL
  fact : 2
   =0 : 2
   =0 = NIL
   fact : 1
    =0 : 1
    =0 = NIL
    fact : 0
     =0 : 0
     =0 = 0
    fact = 1
    * : 1 1
    * = 1
   fact = 1
   * : 2 1
   * = 2
  fact = 2
  * : 3 2
  * = 6
 fact = 6
-> 6
</code></pre>

<p>To reset a function to its untraced state, call <code>untrace</code>

<p><pre><code>
: (untrace 'fact)
-> fact
: (untrace '=0)
-> =0
: (untrace '*)
-> *
</code></pre>

<p>or simply

<p><pre><code>
: (mapc untrace '(fact =0 *))
-> *
</code></pre>

<p><i>Single-stepping</i> means to execute a function step by step, giving the
programmer an opportunity to look more closely at what is happening. The
function <code><a href="ref.html#debug">debug</a></code> inserts a breakpoint
into each top-level expression of a function. When the function is called, it
stops at each breakpoint, displays the expression it is about to execute next
(this expression is also stored into the global variable <code><a
href="ref.html#^">^</a></code>) and enters a read-eval-loop. The programmer can
then

<ul>

<li>inspect the current environment by typing variable names or calling functions

<li>execute <code>(d)</code> to recursively debug the next expression

<li>execute <code>(<a href="ref.html#e">e</a>)</code> to evaluate the next
expression, to see what will happen without actually advancing on

<li>type <code>RETURN</code> (: enter an empty line) to leave the read-eval
loop and continue with the next expression

</ul>

<p>Thus, in the simplest case, single-stepping consists of just hitting
<code>RETURN</code> repeatedly to step through the function.

<p>To try it out, let's look at the <code><a
href="ref.html#stamp">stamp</a></code> system function.

<p><pre><code>
: (pp 'stamp)
(de stamp (Dat Tim)
   (default  Dat (date)  Tim (time))
   (pack (dat$ Dat "-") " " (tim$ Tim T)) )
-> stamp
</code></pre>

<p><pre><code>
: (debug 'stamp)                       # Debug it
-> T
: (stamp)                              # Call it again
(default Dat (date) Tim (time))        # stopped at first expression
!                                      # RETURN
(pack (dat$ Dat "-") " " (tim$ ...     # second expression
! Tim                                  # inspect 'Tim' variable
-> 41908
! (time Tim)                           # convert it
-> (11 38 28)
!                                      # RETURN
-> "2004-10-29 11:38:28"               # done, as there are only 2 expressions
</code></pre>

<p>Now we execute it again, but this time we want to look at what's happening
inside the second expression.

<p><pre><code>
: (stamp)                              # Call it again
(default Dat (date) Tim (time))
!                                      # RETURN
(pack (dat$ Dat "-") " " (tim$ ...     # here we want to look closer
! (d)                                  # debug this expression
-> T
!                                      # RETURN
(dat$ Dat "-")                         # stopped at first subexpression
! (e)                                  # evaluate it
-> "2004-10-29"
!                                      # RETURN
(tim$ Tim T)                           # stopped at second subexpression
! (e)                                  # evaluate it
-> "11:40:44"
!                                      # RETURN
-> "2004-10-29 11:40:44"               # done
</code></pre>

<p>The breakpoints still remain in the function body. We can see them when we
pretty-print it:

<p><pre><code>
: (pp 'stamp)
(de stamp (Dat Tim)
   (! default Dat (date) Tim (time))
   (! pack
      (! dat$ Dat "-")
      " "
      (! tim$ Tim T) ) )
-> stamp
</code></pre>

<p>To reset the function to its normal state, call

<p><pre><code>
: (unbug 'stamp)
</code></pre>

<p>Often, you will not want to single-step a whole function. Just use
<code>edit</code> (see above) to insert a single breakpoint (the exclamation
mark followed by a space) as <code>CAR</code> of an expression, and run your
program. Execution will then stop there as described above; you can inspect the
environment and continue execution with <code>RETURN</code> when you are done.


<p><hr>
<h2><a name="funio">Functional I/O</a></h2>

<p>Input and output in Pico Lisp is functional, in the sense that there are not
variables assigned to file descriptors, which need then to be passed to I/O
functions for reading, writing and closing. Instead, these functions operate on
implicit input and output channels, which are created and maintained as dynamic
environments.

<p>Standard input and standard output are the default channels. Try reading a
single expression:

<p><pre><code>
: (read)
(a b c)        # Console input
-> (a b c)
</code></pre>

<p>To read from a file, we redirect the input with <code><a
href="ref.html#in">in</a></code>. Note that comments and white space are
automatically skipped by <code>read</code>:

<p><pre><code>
: (in "doc/fun.l" (read))
-> (de fact (N) (if (=0 N) 1 (* N (fact (- N 1)))))
</code></pre>

<p>The <code><a href="ref.html#skip">skip</a></code> function can also be used
directly. To get the first non-white character in the file with <code><a
href="ref.html#char">char</a></code>:

<p><pre><code>
: (in "doc/fun.l" (skip "#") (char))
-> "("
</code></pre>

<p><code><a href="ref.html#from">from</a></code> searches through the input
stream for given patterns. Typically, this is not done with Lisp source files
(there are better ways), but for a simple example let's extract all items
immediately following <code>fact</code> in the file,

<p><pre><code>
: (in "doc/fun.l" (make (while (from "fact ") (link (read)))))
-> ((N) (- N 1))
</code></pre>

<p>or the word following "(de " with <code><a
href="ref.html#till">till</a></code>:

<p><pre><code>
: (in "doc/fun.l" (from "(de ") (till " " T)))
-> "fact"
</code></pre>


<p>With <code><a href="ref.html#line">line</a></code>, a line of characters is
read, either into a single transient symbol,

<p><pre><code>
: (in "doc/tut.html" (line T))
-> "&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" ..."
</code></pre>

<p>or into a list of characters:

<p><pre><code>
: (in "doc/tut.html" (line))
-> ("&lt;" "!" "D" "O" "C" "T" "Y" "P" "E" " " "H" "T" "M" "L" ...
</code></pre>

<p><code>line</code> is typically used to read tabular data from a file.
Additional arguments can split the line into fixed-width fields, as described in
the <code><a href="ref.html#line">reference manual</a></code>. If, however, the
data are of variable width, delimited by some special character, the <code><a
href="ref.html#split">split</a></code> function can be used to extract the
fields. A typical way to import the contents of such a file is:

<p><pre><code>
(load "lib/import.l")

(in '("bin/utf2" "importFile.txt")              # Pipe: Convert to UTF-8
   (until (eof)                                 # Process whole file
      (let L (split (line) "^I")                # TAB-delimited data
         ... use 'getStr', 'getNum' etc ...     # process them
</code></pre>

<p>Some more examples:

<p><pre><code>
(in "a"                                         # Copy the first 40 Bytes
   (out "b"                                     # from file "a" to file "b"
      (echo 40) ) )

(in "doc/tut.html"                              # Show the HTTP-header
   (line)
   (echo "&lt;body>") )

(out "file.mac"                                 # Convert to Macintosh
   (in "file.txt"                               # from Unix or DOS format:
      (while (char)
         (prin
            (case @
               ("^M" NIL)                       # ignore CR
               ("^J" "^M")                      # convert CR to LF
               (T @) ) ) ) ) )                  # otherwise no change

(out "c"                                        # Merge the contents of "a"
   (in "b"                                      # and "b" into "c"
      (in "a"
         (while (read)                          # Read an item from "a",
            (println @ (in -1 (read))) ) ) ) )  # print it with an item from "b"
</code></pre>


<p><hr>
<h2><a name="script">Scripting</a></h2>

<p>There are two possibilities to get the Pico Lisp interpreter into doing
useful work: Via command line arguments, or as a stand-alone script.

<p>The command line can specify either files for execution, or arbitrary Lisp
expressions for direct evaluation (see <code><a
href="ref.html#invoc">Invocation</a></code>): If an argument starts with a
hyphen, it is evaluated, otherwise <code><a
href="ref.html#load">load</a></code>ed as a file. A typical invocation might
look like:

<p><pre><code>
$ ./p dbg.l app/file1.l -main app/file2.l
</code></pre>

<p>It loads the debugging environment, an application source file, calls the
main function, and then loads another application source. In a typical
development and debugging session, this line is often modified using the shell's
history mechanisms, e.g. by inserting debugging statements:

<p><pre><code>
$ ./p dbg.l app/file1.l -"trace 'foo" -main -"debug 'bar" app/file2.l
</code></pre>

<p>Another convenience during debugging and testing is to put things into the
command line (shell history) which would otherwise have to be done each time in
the application's user interface:

<p><pre><code>
$ ./p dbg.l app/file1.l -main app/file2.l -go -'login "name" "password"'
</code></pre>

<p>The final production release of an application usually includes a shell
script, which initializes the environment, does some bookkeeping and cleanup,
and calls the application with a proper command line. It is no problem if the
command line is long and complicated.

<p>For small utility programs, however, this is overkill. It is better to write
a single executable file using the mechanisms of "interpreter files": If the
first two characters in an executable file are "<code>#!</code>", the operating
system kernel will pass this file to an interpreter program whose pathname is
given in the first line (optionally followed by a single argument). This is fast
and efficient, because the overhead of a subshell is avoided.

<p>Let's assume you installed Pico Lisp in the directory "/home/foo/picolisp/",
and put links to the executable and the installation directory as:

<p><pre><code>
$ ln -s /home/foo/picolisp/bin/picolisp /usr/bin/picolisp
$ ln -s /home/foo/picolisp /usr/lib/picolisp
</code></pre>

Then a simple hello-world script might look like:

<p><pre><code>
#!/usr/bin/picolisp /usr/lib/picolisp/lib.l
(prinl "Hello world!")
(bye)
</code></pre>

<p>If you write this into a text file, and use <code>chmod</code> to set it to
"executable", it can be executed like any other command. Note that - because
<code>#</code> is the comment character in Pico Lisp - the first line will not
be interpreted, and you can still use that file as a normal command line
argument to Pico Lisp (useful during debugging).

<p>The fact that a hyphen causes evaluation of command line arguments can be
used to simulate something like command line options. The following script
defines two functions <code>a</code> and <code>f</code>, and then calls
<code>(load T)</code> to process the rest of the command line (which otherwise
would be ignored because of the <code>(bye)</code> statement):

<p><pre><code>
#!/usr/bin/picolisp /usr/lib/picolisp/lib.l

(de a ()
   (println '-a '-> (opt)) )

(de f ()
   (println '-f '-> (opt)) )

(load T)
(bye)
</code></pre>

<p>Calling this script (let's say we named it "testOpts") gives:

<p><pre><code>
$ ./testOpts -f abc
-f -> "abc"
$ ./testOpts -a xxx  -f yyy
-a -> "xxx"
-f -> "yyy"
</code></pre>

<p>We have to be aware of the fact, however, that the aggregation of arguments
like

<p><pre><code>
$ ./testOpts -axxx  -fyyy
</code></pre>

<p>or

<p><pre><code>
$ ./testOpts -af yyy
</code></pre>

<p>cannot be achieved with this simple and general mechanism of command line
processing.

<p>Utilities are typically used outside the context of the Pico Lisp
environment. All examples above assumed that the current working directory is
the Pico Lisp installation directory, which is usually all right for
applications developed in that environment. Command line file arguments like
"dbg.l" or "app/file1.l" will be properly found.

<p>To allow utilities to run in arbitrary places on the host file system, the
concept of <i>home directory substitution</i> was introduced. The interpreter
remembers internally at start-up the pathname of its first argument (usually
"lib.l"), and substitutes any leading "<code>@</code>" character in subsequent
file names with that pathname. Thus, to run the above example in some other
place, simply write:

<p><pre><code>
$ /home/foo/picolisp/p @dbg.l @app/file1.l -main @app/file2.l
</code></pre>

<p>that is, supply a full path name to the initial command (here 'p'), or put it
into your <code>PATH</code> variable, and prefix each file which has to be
loaded from the Pico Lisp home directory with a <code>@</code> character.
"Normal" files (not prefixed by <code>@</code>) will be opened or created
relative to the current working directory as usual.

<p>Stand-alone scripts will often want to load additional modules from the Pico
Lisp environment, beyond the "lib.l" we provided in the first line of the
hello-world script. Typically, at least a call to

<p><pre><code>
(load "@lib/misc.l")
</code></pre>

<p>(note the home directory substitution) will be included near the beginning of
the script.

<p>As a more complete example, here is a script which extracts the date, name
and size of the latest official Pico Lisp release version from the download web
site, and prints it to standard output:

<p><pre><code>
#!/usr/bin/picolisp /usr/lib/picolisp/lib.l

(load "@lib/misc.l" "@lib/http.l")

(use (@Date @Name @Size)
   (when
      (match
         '(@Date " " "-" " " @Name " " "(" @Size ")")
         (client "software-lab.de" 80 "down.html"
            (from "Archive")
            (from ".tgz\">")
            (till "<") ) )
      (prinl @Name)
      (prinl @Date " -- " @Size) ) )

(bye)
</code></pre>


<p><hr>
<h2><a name="oop">Objects and Classes</a></h2>

<p>The Pico Lisp object model is very simple, yet flexible and powerful. Objects
as well as classes are both implemented as symbols. In fact, there is no formal
difference between objects and classes; classes are more a conceptual design
consideration in the head of the programmer than a physical reality.

<p>Having said this, we declare that normally:

<ol>
<li>A Class
   <ul>
   <li>Has a name (interned symbol)
   <li>Has method definitions and superclass(es) in the value cell
   <li>May have class variables (attributes) in the property list
   </ul>
<li>An Object
   <ul>
   <li>Has no name (anonymous symbol) or is an external symbol
   <li>Has class(es) and (optionally method definitions) and in the value cell
   <li>Has instance variables (attributes) in the property list
   </ul>
</ol>

<p>So the main difference between classes and objects is that the former ones
usually are internal symbols. By convention, their names start with a
'<code>+</code>'. Sometimes it makes sense, however, to create named objects (as
global singletons, for example), or even anonymous classes.

<p>Both classes and objects have a list in their value cell, consisting of
method definitions (often empty for objects) and (super)class(es). And both
classes and objects have local data in their property lists (often empty for
classes). This implies, that any given object (as an instance of a class) may
have private (object-local) methods defined.

<p>It is rather difficult to contrive a simple OOP example. We constructed a
hierarchy of geometric shapes, with a base class <code>+Shape</code> and two
subclasses <code>+Rectangle</code> and <code>+Circle</code>.

<p>The source code is included as "<code><a
href="shape.l">doc/shape.l</a></code>" in the Pico Lisp distribution, so you
don't have to type it in. Just <code><a href="ref.html#load">load</a></code> the
file, or start it from the shell as:

<p><pre><code>
$ ./p dbg.l doc/shape.l
</code></pre>

<p>Let's look at it piece by piece. Here's the base class:

<p><pre><code>
(class +Shape)
# x y

(dm T (X Y)
   (=: x X)
   (=: y Y) )

(dm move> (DX DY)
   (inc (:: x) DX)
   (inc (:: y) DY) )
</code></pre>

<p>The first line '<code>(class +Shape)</code>' defines the symbol
<code>+Shape</code> as a class without superclasses. The following method
definitions will go to that class.

<p>The comment '<code># x y</code>' in the second line is just a convention, to
indicate what instance variables (properties) that class uses. As Pico Lisp is a
dynamic language, a class can be extended at runtime with any number of
properties, and there is nothing like a fixed object size or structure. This
comment is a hint of what the programmer thinks to be essential and typical for
that class. In the case of <code>+Shape</code>, <code>x</code> and
<code>y</code> are the coordinates of the shape's origin.

<p>Then we have two method definitions, using the keyword <code><a
href="ref.html#dm">dm</a></code> for "define method". The first method is
special, in that its name is <code>T</code>. Each time a new object is created,
and a method with that name is found in its class hierarchy, that method will be
executed. Though this looks like a "constructor" in other programming languages,
it should probably better be called "initializer". The <code>T</code> method of
<code>+Shape</code> takes two arguments <code>X</code> and <code>Y</code>, and
stores them in the object's property list.

<p>The second method <code>move&gt;</code> changes the object's origin by adding
the offset values <code>DX</code> and <code>DY</code> to the object's origin.

<p>Now to the first derived class:

<p><pre><code>
(class +Rectangle +Shape)
# dx dy

(dm T (X Y DX DY)
   (super X Y)
   (=: dx DX)
   (=: dy DY) )

(dm area> ()
   (* (: dx) (: dy)) )

(dm perimeter> ()
   (* 2 (+ (: dx) (: dy))) )

(dm draw> ()
   (drawRect (: x) (: y) (: dx) (: dy)) )
</code></pre>

<p><code>+Rectangle</code> is defined as a subclass of <code>+Shape</code>.
The comment '<code># dx dy</code>' indicates that <code>+Rectangle</code> has a
width and a height in addition to the origin coordinates inherited from
<code>+Shape</code>.

<p>The <code>T</code> method passes the origin coordinates <code>X</code> and
<code>Y</code> to the <code>T</code> method of the superclass
(<code>+Shape</code>), then stores the width and height parameters into
<code>dx</code> and <code>dy</code>.

<p>Next we define the methods <code>area&gt;</code> and
<code>perimeter&gt;</code> which do some obvious calculations, and a method
<code>draw&gt;</code> which is supposed to draw the shape on the screen by
calling some hypothetical function <code>drawRect</code>.

<p>Finally, we define a <code>+Circle</code> class in an analog way, postulating
the hypothetical function <code>drawCircle</code>:

<p><pre><code>
(class +Circle +Shape)
# r

(dm T (X Y R)
   (super X Y)
   (=: r R) )

(dm area> ()
   (*/ (: r) (: r) 31415927 10000000) )

(dm perimeter> ()
   (*/ 2 (: r) 31415927 10000000) )

(dm draw> ()
   (drawCircle (: x) (: y) (: r)) )
</code></pre>

<p>Now we can experiment with geometrical shapes. We create a rectangle at point
(0,0) with a width of 30 and a height of 20, and keep it in the variable
<code>R</code>:

<p><pre><code>
: (setq R (new '(+Rectangle) 0 0 30 20))  # New rectangle
-> $134432824                             # returned anonymous symbol
: (show R)
$134432824 (+Rectangle)                   # Show the rectangle
   dy 20
   dx 30
   y 0
   x 0
</code></pre>

<p>We see that the symbol <code>$134432824</code> has a list of classes
'<code>(+Rectangle)</code>' in its value cell, and the coordinates, width and
height in is property list.

<p>Sending messages to that object

<p><pre><code>
: (area> R)                               # Calculate area
-> 600
: (perimeter> R)                          # and perimeter
-> 100
</code></pre>

<p>will return the values for area and perimeter, respectively.

<p>Then we move the object's origin:

<p><pre><code>
: (move> R 10 5)                          # Move 10 right and 5 down
-> 5
: (show R)
$134432824 (+Rectangle)
   y 5                                    # Origin changed (0,0) -> (10,5)
   x 10
   dy 20
   dx 30
</code></pre>

<p>Though a method <code>move&gt;</code> wasn't defined for the
<code>+Rectangle</code> class, it is inherited from the <code>+Shape</code>
superclass.

<p>Similarly, we create and use a circle object:

<p><pre><code>
: (setq C (new '(+Circle) 10 10 30))      # New circle
-> $134432607                             # returned anonymous symbol
: (show C)
$134432607 (+Circle)                      # Show the circle
   r 30
   y 10
   x 10
-> $134432607
: (area> C)                               # Calculate area
-> 2827
: (perimeter> C)                          # and perimeter
-> 188
: (move> C 10 5)                          # Move 10 right and 5 down
-> 15
: (show C)
$134432607 (+Circle)                      # Origin changed (10,10) -> (20,15)
   y 15
   x 20
   r 30
</code></pre>

<p>It is also easy to send messages to objects in a list:

<p><pre><code>
: (mapcar 'area> (list R C))              # Get list of areas
-> (600 2827)
: (mapc
   '((Shape) (move> Shape 10 10))         # Move all 10 right and down
   (list R C) )
-> 25
: (show R)
$134431493 (+Rectangle)
   y 15
   x 20
   dy 20
   dx 30
-> $134431493
: (show C)
$134431523 (+Circle)
   y 25
   x 30
   r 30
</code></pre>

<p>Assume that we want to extend our shape system. From time to time, we need
shapes that behave exactly like the ones above, but are tied to a fixed
position. That is, they do not change their position even if they receive a
<code>move&gt;</code> message.

<p>One solution would be to modify the <code>move&gt;</code> method in the
<code>+Shape</code> class to a no-operation. But this would require to duplicate
the whole shape hierarchy (e.g. by defining <code>+FixedShape</code>,
<code>+FixedRectangle</code> and <code>+FixedCircle</code> classes).

<p>The Pico Lisp Way is the use of <u>Prefix Classes</u> through multiple
inheritance. It uses the fact that searching for method definitions is a
depth-first, left-to-right search of the class tree. We define a prefix class:

<p><pre><code>
: (class +Fixed)

(dm move> (DX DY))  # A do-nothing method
</code></pre>

<p>We can now create a fixed rectangle, and try to move it:

<p><pre><code>
: (setq R (new '(+Fixed +Rectangle) 0 0 30 20))    # '+Fixed' prefix class
-> $134432881
: (move> R 10 5)                                   # Send 'move>' message
-> NIL
: (show R)
$134432881 (+Fixed +Rectangle)
   dy 20
   dx 30
   y 0                                             # Did not move!
   x 0
</code></pre>

<p>We see, prefix classes can surgically change the inheritance tree for
selected objects or classes.

<p>Alternatively, if fixed rectangles are needed often, it might make sense to
define a new class <code>+FixRect</code>:

<p><pre><code>
: (class +FixRect +Fixed +Rectangle)
-> +FixRect
</code></pre>

<p>and then use it directly:

<p><pre><code>
: (setq R (new '(+FixRect) 0 0 30 20))
-> $13455710
</code></pre>


<p><hr>
<h2><a name="ext">Persistence (External Symbols)</a></h2>

<p>Pico Lisp has persistent objects built-in as a first class data type. With
"first class" we mean not just the ability of being passed around, or returned
from functions (that's a matter of course), but that they are a primary data
type with their own interpreter tag bits. They are, in fact, a special type of
symbolic atoms (called "<a href="ref.html#external">External Symbols</a>"), that
happen to be read from a pool file when accessed, and written back automatically
when modified.

<p>In all other aspects they are normal symbols. They have a value cell, a
property list and a name.

<p>The name cannot be directly controlled by the programmer, as it is assigned
when the symbol is created. It is an encoded index of the symbol's location in
the pool file ("database"). In its visual representation (output by the <code><a
href="ref.html#print">print</a></code> functions and input by the <code><a
href="ref.html#read">read</a></code> functions) it is surrounded by braces.

<p>To make use of external symbols, you need to open a database file first:

<p><pre><code>
: (pool "test.db")
</code></pre>

<p>If a file with that name did not exist, it got created now. Also created at
the same moment was <code>{1}</code>, the very first symbol in the file. This
symbol is of great importance, and is handled especially by Pico Lisp. Therefore
a global constant <code><a href="ref.html#*DB">*DB</a></code> exists, which
points to that symbol <code>{1}</code>, which should be used exclusively to
access the symbol <code>{1}</code>, and which should never be modified by the
programmer.

<p><pre><code>
: *DB                   # The value of '*DB'
-> {1}                  # is '{1}'
: (show *DB)
{1} NIL                 # Value of '{1}' is NIL, property list empty
</code></pre>

<p>Now let's put something into the value cell and property list of
<code>{1}</code>.

<p><pre><code>
: (set *DB "Hello world")  # Set value of '{1}' to a transient symbol (string)
-> "Hello world"
: (put *DB 'a 1)           # Property 'a' to 1
-> 1
: (put *DB 'b 2)           # Property 'b' to 2
-> 2
: (show *DB)               # Now show the symbol '{1}'
{1} "Hello world"
   b 2
   a 1
</code></pre>

<p>Note that instead of '<code>(set *DB "Hello world")</code>', we might
also have written '<code>(setq {1} "Hello world")</code>', and instead of
'<code>(put *DB 'a 1)</code>' we might have written '<code>(put '{1} 'a
1)</code>'. This would have the same effect, but as a rule external symbols
should never be be accessed literally in application programs, because the
garbage collector might not be able to free these symbols and all symbols
connected to them (and that might well be the whole database). It is all right,
however, to access external symbols literally during interactive debugging.

<p>Now we can create own first own external symbol. This can be done with
<code><a href="ref.html#new">new</a></code> when a <code>T</code> argument is
supplied:

<p><pre><code>
: (new T)
-> {2}               # Got a new symbol
</code></pre>

<p>We store it in the database root <code>{1}</code>:

<p><pre><code>
: (put *DB 'newSym '{2})   # Literal '{2}' (ok during debugging)
-> {2}
: (show *DB)
{1} "Hello world"
   newSym {2}              # '{2}' is now stored in '{1}'
   b 2
   a 1
</code></pre>

<p>Put some property value into '{2}'

<p><pre><code>
: (put *DB 'newSym 'x 777) # Put 777 as 'x'-property of '{2}'
-> 777
: (show *DB 'newSym)       # Show '{2}' (indirectly)
{2} NIL
   x 777
-> {2}
: (show '{2})              # Show '{2}' (directly)
{2} NIL
   x 777
</code></pre>

<p>All modifications to - and creations of - external symbols done so far are
not written to the database yet. We could call <code><a
href="ref.html#rollback">rollback</a></code> (or simply exit Pico Lisp) to undo
all the changes. But as we want to keep them:

<p><pre><code>
: (commit)           # Commit all changes
-> T
: (bye)              # Exit picolisp
$                    # back to the shell
</code></pre>

<p>So, the next time when ..

<p><pre><code>
$ ./p dbg.l             # .. we start Pico Lisp
: (pool "test.db")      # and open the database file,
-> T
: (show *DB)            # our two symbols are there again
{1} "Hello world"
   newSym {2}
   b 2
   a 1
-> {1}
: (show *DB 'newSym)
{2} NIL
   x 777
-> {2}
</code></pre>


<p><hr>
<h2><a name="db">Database Programming</a></h2>

<p>To a database, there is more than just persistence. Pico Lisp includes an
entity/relation class framework (see also <a href="ref.html#dbase">Database</a>)
which allows a close mapping of the application data structure to the database.

<p>We provided a simple yet complete database and GUI demo application in
<code><a href="family.l">doc/family.l</a></code>. We recommend to start it up
for test purposes in the following way:

<p><pre><code>
$ ./p dbg.l doc/family.l -main
:
</code></pre>

<p>This loads the source file, initializes the database by calling the
<code>main</code> function, and prompts for user input.

<p>The data model is small and simple. We define a class <code>+Person</code>
and two subclasses <code>+Man</code> and <code>+Woman</code>.

<p><pre><code>
(class +Person +Entity)
</code></pre>

<p><code>+Person</code> is a subclass of the <code>+Entity</code> system class.
Usually all objects in a database are of a direct or indirect subclass of
<code>+Entity</code>. We can then define the relations to other data with the
<code><a href="ref.html#rel">rel</a></code> function.

<p><pre><code>
(rel nm     (+Need +Sn +Idx +String))           # Name
</code></pre>

<p>This defines the name property (<code>nm</code>) of a person. The first
argument to <code>rel</code> is always a list of relation classes (subclasses of
<code>+Relation</code>), optionally followed by further arguments, causing
relation daemon objects be created and stored in the class definition. These
daemon objects control the entity's behavior later at runtime.

<p>Relation daemons are a kind of <i>metadata</i>, controlling the interactions
between entities, and maintaining database integrity. Like other classes,
relation classes can be extended and refined, and in combination with proper
prefix classes a fine-grained description of the application's structure can be
produced.

<p>Besides primitive relation classes, like <code>+Number</code>,
<code>+String</code> or <code>+Date</code>, there are

<ul>

<li>relations between entities, like <code>+Link</code> (unidirectional link),
<code>+Joint</code> (bidirectional link) or <code>+Hook</code> (object-local
index trees)

<li>relations that bundle other relations into a single unit (<code>+Bag</code>)

<li>a <code>+List</code> prefix class

<li>a <code>+Blob</code> class for "binary large objects"

<li>prefix classes that maintain index trees, like <code>+Key</code> (unique
index), <code>+Ref</code> (non-unique index) or <code>+Idx</code> (full text
index)

<li>prefix classes which in turn modify index class behavior, like
<code>+Sn</code> (soundex algorithm [<a href="#knuth73">knuth73</a>] for
tolerant searches)

<li>a <code>+Need</code> prefix class, for existence checks

<li>a <code>+Dep</code> prefix class controlling dependencies between other
relations

</ul>

<p>In the case of the person's name (<code>nm</code>) above, the relation object
is of type <code>(+Need +Sn +Idx +String)</code>. Thus, the name of each person
in this demo database is a mandatory attribute (<code>+Need</code>), searchable
with the soundex algorithm (<code>+Sn</code>) and a full index
(<code>+Idx</code>) of type <code>+String</code>.

<p><pre><code>
(rel pa     (+Joint) kids (+Man))               # Father
(rel ma     (+Joint) kids (+Woman))             # Mother
(rel mate   (+Joint) mate (+Person))            # Partner
</code></pre>

<p>The attributes for <i>father</i> (<code>pa</code>), <i>Mother</i>
(<code>ma</code>) and <i>partner</i> (<code>mate</code>) are all defined as
<code>+Joint</code>s. A <code>+Joint</code> is probably the most powerful
relation mechanism in Pico Lisp; it establishes a bidirectional link between
two objects.

<p>The above declarations say that the <i>father</i> (<code>pa</code>) attribute
points to an object of type <code>+Man</code>, and is joined with that object's
<code>kids</code> attribute (which is a list of joints back to all his
children).

<p>The consistency of <code>+Joint</code>s is maintained automatically by the
relation daemons. These become active whenever a value is stored to a person's
<code>pa</code>, <code>ma</code>, <code>mate</code> or <code>kids</code>
property.

<p>For example, interesting things happen when a person's <code>mate</code> is
changed to a new value. Then the <code>mate</code> property of the old mate's
object is cleared (she has no mate after that). Now when the person pointed to
by the new value already has a mate, then that mate's <code>mate</code> property
gets cleared, and the happy new two mates now get their joints both set
correctly.

<p>The programmer doesn't have to care about all that. He just declares these
relations as <code>+Joint</code>s.

<p>The last four attributes of person objects are just static data:

<p><pre><code>
(rel job    (+Ref +String))                     # Occupation
(rel dat    (+Ref +Date))                       # Date of birth
(rel fin    (+Ref +Date))                       # Date of death
(rel txt    (+String))                          # Info
</code></pre>

<p>They are all searchable via a non-unique index (<code>+Ref</code>). Date
values in Pico Lisp are just numbers, representing the numbers of days since
first of March in the year zero.

<p>A method <code>url&gt;</code> is defined:

<p><pre><code>
(dm url> ()
   (list "@person" '*ID This) )
</code></pre>

<p>It is needed later in the GUI, to cause a click on a link to switch to that
object.

<p>The classes <code>+Man</code> and <code>+Woman</code> are subclasses of
<code>+Person</code>:

<p><pre><code>
(class +Man +Person)
(rel kids   (+List +Joint) pa (+Person))        # Children

(class +Woman +Person)
(rel kids   (+List +Joint) ma (+Person))        # Children
</code></pre>

<p>They inherit everything from <code>+Person</code>, except for the
<code>kids</code> attribute. This attribute joins with the <code>pa</code> or
<code>ma</code> attribute of the child, depending on the parent's gender.

<p>That's the whole data model for our demo database application.

<p>It is followed by a call to <code>dbs</code> ("database sizes"). This call is
optional. If it is not present, the whole database will reside in a single file,
with a block size of 256 bytes. If it is given, it should specify a list of
items, each having a number in its <code>CAR</code>, and a list in its
<code>CDR</code>. The <code>CAR</code>s taken together will be passed later to
<a href="ref.html#pool">pool</a>, causing an individual database file with that
size to be created. The <code>CDR</code>s tell what entity classes (if an item
is a symbol) or index trees (if an item is a list with a class in its
<code>CAR</code> and a list of relations in its <code>CDR</code>) should be
placed into that file.


<p>A handful of access functions is provided, that know about database
relationships and thus allows higher-level access modes to the external symbols
in a database.

<p>For one thing, the B-Trees created and maintained by the index daemons can be
used directly. Though this is rarely done in a typical application, they form
the base mechanisms of other access modes and should be understood first.

<p>The function <code>tree</code> returns the tree structure for a given
relation. To iterate over the whole tree, the functions <code>iter</code> and
<code>scan</code> can be used:

<p><pre><code>
(iter (tree 'dat '+Person) '((P) (println (datStr (get P 'dat)) (get P 'nm))))
"1770-08-03" "Friedrich Wilhelm III"
"1776-03-10" "Luise Augusta of Mecklenburg-Strelitz"
"1797-03-22" "Wilhelm I"
...
</code></pre>

<p>They take a function as the first argument. It will be applied to all objects
found in the tree (to show only a part of the tree, an optional begin- and
end-value can be supplied), producing a simple kind of report.

<p>More useful is <code>collect</code>; it returns a list of all objects that
fall into a range of index values:

<p><pre><code>
: (collect 'dat '+Person (date 1982 1 1) (date 1988 12 31))
-> ({2-M} {2-L} {2-E})
</code></pre>

<p>This returns all persons born between 1982 and 1988. Let's look at them with
<code>show</code>:

<p><pre><code>
: (more (collect 'dat '+Person (date 1982 1 1) (date 1988 12 31)) show)
{2-M} (+Man)
   nm William
   dat 724023
   ma {2-K}
   pa {2-J}
   job Heir to the throne

{2-L} (+Man)
   nm Henry
   dat 724840
   ma {2-K}
   pa {2-J}
   job Prince

{2-E} (+Woman)
   nm Beatrice
   dat 726263
   ma {2-D}
   job Princess
   pa {2-B}
</code></pre>

<p>If you are only interested in a certain attribute, e.g. the name, you can
return it directly:

<p><pre><code>
: (collect 'dat '+Person (date 1982 1 1) (date 1988 12 31) 'nm)
-> ("William" "Henry" "Beatrice")
</code></pre>

<p>To find a single object in the database, the function <code>db</code> is
used:

<p><pre><code>
: (db 'nm '+Person "Edward")
-> {2-;}
</code></pre>

<p>If the key is not unique, additional arguments may be supplied:

<p><pre><code>
: (db 'nm '+Person "Edward"  'job "Prince"  'dat (date 1964 3 10))
-> {2-;}
</code></pre>

<p>The programmer must know which combination of keys will suffice to specify
the object uniquely. The tree search is performed using the first value
("Edward"), while all other attributes are used for filtering. Later, in
the <a href="#pilog">Pilog</a> section, we will show how more general (and
possibly more efficient) searches can be performed.


<p><hr>
<h2><a name="gui">User Interface (GUI) Programming</a></h2>

<p>The only types of GUI supported by the Pico Lisp application server framework
is either dynamically generated (but static by nature) HTML, an interactive
frontend using Java applets, or an XHTML/CSS framework with the optional use of
JavaScript.

<p>Before we explain the GUI of our demo database application, we present a
minimal example for a plain HTML-GUI in <code><a
href="hello.l">doc/hello.l</a></code>. Start the application server as:

<p><pre><code>
$ ./p lib/http.l -'server 8080 "doc/hello.l"' -wait
</code></pre>

<p>Now point your browser to the address '<code><a
href="http://localhost:8080">http://localhost:8080</a></code>'. You should see a
very simple HTML page. You can come back here with normal browser navigation, or
with the '<code>&lt;&lt;&lt;</code>' link in the upper right corner.

<p>You can call the page repeatedly, or concurrently with many clients if you
like. To terminate the server, you have to send it a TERM signal (e.g.
'<code>killall picolisp</code>'), or type the <code>Ctrl-C</code> key in the
console window.

<p>In our demo database application, a single function <code>person</code> is
responsible for the whole GUI. Again, please look at <code><a
href="family.l">doc/family.l</a></code>.

<p>To start the database <i>and</i> the application server, call:

<p><pre><code>
$ ./p dbg.l doc/family.l -main -go
</code></pre>

<p>As before, the database is opened with <code>main</code>. The function
<code>go</code> is also defined in <code>doc/family.l</code>:

<p><pre><code>
(de go ()
   (server 8080 "@person") )
</code></pre>

<p>It starts the <code>HTTP</code> server listening on TCP port 8080 (we did a
similar thing in our minimal GUI example above directly on the command line).
Each connect to that port will cause the function <code>person</code> to be
invoked.

<p>Again, point your browser to the address '<code><a
href="http://localhost:8080" target="GUI">http://localhost:8080</a></code>'.

<p>You should see a new browser window with an input form created by the
function <code>person</code>. We provided an initial database in
"doc/family[1-4]". You can navigate through it by clicking on the pencil icons
besides the input fields.

<p>The chart with the children data can be scrolled using the down
(<code>v</code>) and up (<code>^</code>) buttons.

<p>A click on the button "Select" below opens a search dialog. You can scroll
through the chart as before. Again, a click on a pencil will jump to that
person. You can abort the dialog with a click on the "Cancel"-button.

<p>The search fields in the upper part of the dialog allow a conjunctive search.
If you enter "Edward" in the "Name" field and click "Search", you'll see all
persons having the string "Edward" in their name. If you also enter "Duke" in
the "Occupation" field, the result list will reduce to only two entries.

<p>To create a new person, press the "New Man" or "New Woman" button. A new
empty form will be displayed. Please type a name into the first field, and
perhaps also an occupation and birth date. Any change of contents should be
followed by a press on the "Save" button, though any other button (also Scroll
or Select-buttons) will also do.

<p>To assign a <i>father</i> attribute, you can either type a name directly into
the field (if that person already exists in the database and you know the exact
spelling), or use the "Set"-button (<code>-&gt;</code>) to the left of that
field to open the search dialog. If you type in the name directly, your input
must exactly match upper and lower case.

<p>Alternatively, you may create a new person and assign a child in the
"Children" chart.

<p>On the console where you started Pico Lisp, there should a prompt have
appeared just when the browser connected. You can debug the application
interactively while it is running. For example, the global variable
<code>*Top</code> always contains the top level GUI object:

<p><pre><code>
: (show *Top)
</code></pre>

<p>To take a look at the first field on the form:

<p><pre><code>
: (show *Top 'gui 1)
</code></pre>

<p>A production application would be started in a slightly different way:

<p><pre><code>
$ ./p doc/family.l -main -go -wait
</code></pre>

<p>In that case, no debug prompt will appear. In both cases, however, two
<code>picolisp</code> processes will be running now. One is the initial server
process which will continue to run until it is killed. The other is a child
process which is connected to the applet in the browser, it will terminate when
the browser is closed, or when <code>(bye)</code> or a plain <code>RETURN</code>
is entered at the Pico Lisp prompt.

<p>Now back to the explanation of the GUI function <code>person</code>:

<p><pre><code>
(de person ()
   (app)
   (action
      (html 0 (get (default *ID (seq (db: +Person))) 'nm) "lib.css" NIL
         (form NIL
            (&lt;h3&gt; (&lt;id&gt; (: nm)))
</code></pre>

<p>For an in-depth explanation of that startup code, please refer to the guide
to <a href="app.html">Pico Lisp Application Development</a>.

<p>All components like fields and buttons are controlled by <code>form</code>.
The function <code>gui</code> creates a single GUI component and takes the type
(a list of classes) and a variable number of arguments depending on the needs of
these classes.

<p><pre><code>
   (gui '(+E/R +TextField) '(nm : home obj) 40 "Name")
</code></pre>

<p>This creates a <code>+TextField</code> with the label "Name" and a length of
40 characters. The <code>+E/R</code> (: Entity/Relation) prefix class connects
that field to a database object, the <code>nm</code> attribute of a person in
this case, so that the person's name is displayed in that text field, and any
changes entered into that field are propagated to the database automatically.

<p><pre><code>
   (gui '(+ClassField) '(: home obj) '(("Male" +Man) ("Female" +Woman)))
</code></pre>

<p>A <code>+ClassField</code> displays and changes the class of an object, in
this case the person's sex from <code>+Man</code> to <code>+Woman</code> and
vice versa.

<p>As you see, there is no place where explicit accesses to the database have to
be programmed, no <code>select</code> or <code>update</code>. This is all
encapsulated in the GUI components, mainly in the <code>+E/R</code> prefix
class. The above function <code>person</code> is fully functional as we present
it and allows creation, modification and deletion of person objects in the
database.

<p>The two buttons on the bottom right generate simple reports:

<p>The first one shows all contemporaries of the person that is currently
displayed, i.e. all persons who did not die before, or were not born after that
person. This is a typical Pico Lisp report, in that in addition to the report's
HTML page, a temporary file may be generated, suitable for download (and import
into a spread sheet), and from which a PDF can be produced for print-out.

<p>In Pico Lisp, there is not a real difference between a plain HTML-GUI and a
report. Again, the function <code>html</code> is used to generate the page.

<p>The second report is much simpler. It produces a recursive structure of the
family.

<p>In both reports, links to the person objects are created which allow easy
navigation through the database.


<p><hr>
<h2><a name="pilog">Pilog -- Pico Lisp Prolog</a></h2>

<p>This sections explains some cases of using Pilog in typical application
programming, in combination with persistent objects and databases. Please refer
to the <a href="ref.html#pilog">Pilog</a> section of the Pico Lisp Reference for
the basic usage of Pilog.

<p>Again, we use our demo application <code><a
href="family.l">doc/family.l</a></code> that was introduced in the <a
href="#db">Database Programming</a> section.

<p>Normally, Pilog is used either interactively to query the database during
debugging, or in applications to generate export data and reports. In the
following examples we use the interactive query frontend functions <code><a
href="ref.html#quest">?</a></code> and <code>select</code>. An application will
use <code><a href="ref.html#goal">goal</a></code> and <code><a
href="ref.html#prove">prove</a></code> directly, or use convenience functions
like <code>pilog</code> or <code>solve</code>.

<p>All Pilog access to external symbols is done via the two predicates
<code>db</code> and <code>select</code>.

<ul>

<li><code>db</code> corresponds to the Lisp-level functions <code>db</code> and
<code>collect</code>, as it derives its data from a single relation. It can be
used for simple database queries.

<li><code>select</code> provides for self-optimizing parallel access to an
arbitrary number of relations. There is also a Lisp frontend function
<code>select</code>, for convenient calls to the Pilog <code>select</code>
predicate.

</ul>

<p>A predicate <code>show</code> is pre-defined for debugging purposes (a simple
glue to the Lisp-level function <code>show</code>, see <a
href="#brw">Browsing</a>). Searching with <code>db</code> for all persons having
the string "Edward" in their name:

<p><pre><code>
: (? (db nm +Person "Edward" @P) (show @P))
{2-;} (+Man)
   nm "Edward"
   ma {2-:}
   pa {2-A}
   dat 717346
   job "Prince"
 @P={2-;}
{2-1B} (+Man)
   nm "Albert Edward"
   kids ({2-1C} {2-1D} {2-1E} {2-1F} {2-1G} {2-1H} {2-1I} {2-g} {2-a})
   job "Prince"
   mate {2-f}
   fin 680370
   dat 664554
 @P={2-1B}
...               # more results
</code></pre>

<p>To search for all persons with "Edward" in their name who are married to
somebody with occupation "Queen":

<p><pre><code>
: (? (db nm +Person "Edward" @P) (val "Queen" @P mate job) (show @P))
{2-1B} (+Man)
   mate {2-f}
   nm "Albert Edward"
   kids ({2-1C} {2-1D} {2-1E} {2-1F} {2-1G} {2-1H} {2-1I} {2-g} {2-a})
   job "Prince"
   fin 680370
   dat 664554
 @P={2-1B}
-> NIL            # only one result
</code></pre>

<p>If you are interested in the names of "Albert Edward"'s children:

<p><pre><code>
: (? (db nm +Person "Albert Edward" @P) (lst @K @P kids) (val @Kid @K nm))
 @P={2-1B} @K={2-1C} @Kid="Beatrice Mary Victoria"
 @P={2-1B} @K={2-1D} @Kid="Leopold George Duncan"
 @P={2-1B} @K={2-1E} @Kid="Arthur William Patrick"
 @P={2-1B} @K={2-1F} @Kid="Louise Caroline Alberta"
 @P={2-1B} @K={2-1G} @Kid="Helena Augusta Victoria"
 @P={2-1B} @K={2-1H} @Kid="Alfred Ernest Albert"
 @P={2-1B} @K={2-1I} @Kid="Alice Maud Mary"
 @P={2-1B} @K={2-g} @Kid="Victoria Adelaide Mary"
 @P={2-1B} @K={2-a} @Kid="Edward VII"
-> NIL
</code></pre>

<p><code>db</code> can do a direct index access only for a single attribute
(<code>nm</code> of <code>+Person</code> above). To search for several criteria
at the same time, <code>select</code> has to be used:

<p><pre><code>
: (?
   (select (@P)
      ((nm +Person "Edward") (nm +Person "Augusta" pa))  # Generator clauses
      (tolr "Edward" @P nm)                              # Filter clauses
      (tolr "Augusta" @P kids nm) )
   (show @P) )
{2-1B} (+Man)
   kids ({2-1C} {2-1D} {2-1E} {2-1F} {2-1G} {2-1H} {2-1I} {2-g} {2-a})
   mate {2-f}
   nm "Albert Edward"
   job "Prince"
   fin 680370
   dat 664554
 @P={2-1B}
-> NIL
</code></pre>

<p><code>select</code> takes a list of generator clauses which are used to
retrieve objects from the database, and a number of normal Pilog filter clauses.
In the example above the generators are

<ul>

<li><code>(nm +Person "Edward")</code> to generate persons with "Edward" in
their names, and

<li><code>(nm +Person "Augusta" pa)</code> to find persons with "Augusta" in
their names and generate persons using the <code>pa</code> ("father") attribute.

</ul>

<p>All persons generated are possible candidates for our selection. The
<code>nm</code> index tree of <code>+Person</code> is traversed twice in
parallel, optimizing the search in such a way that successful hits get higher
priority in the search, depending on the filter clauses. The process will stop
as soon as any one of the generators is exhausted. Note that this is different
from the standard Prolog search algorithm.

<p>The filter clauses in this example both use the pre-defined predicate
<code>tolr</code> for <i>tolerant</i> string matches (according either to the
soundex algorithm (see the section <a href="#db">Database Programming</a>) or to
substring matches), and filter objects that

<ul>

<li>match "Edward" in their name: <code>(tolr "Edward" @P nm)</code>, and

<li>match "Augusta" in one of their kids' names: <code>(tolr "Augusta" @P kids nm)</code>

</ul>

<p>A more typical and extensive example for the usage of <code>select</code> can
be found in the <code>qPerson</code> function in <code><a
href="family.l">doc/family.l</a></code>. It is used in the search dialog of the
demo application, and searches for a person with the name, the parents' and
partner's names, the occupation and a time range for the birth date. The
relevant index trees in the database are searched (actually only those trees
where the user entered a search key in the corresponding dialog field), and a
logical AND of the search attributes is applied to the result.

<p>For example, press the "Select" button, enter "Elizabeth" into the "Mother"
search field and "Phil" in the "Partner" search field, meaning to look for all
persons whose mother's name is like "Elizabeth" and whose partner's name is like
"Phil". As a result, two persons ("Elizabeth II" and "Anne") will show up.

<p>In principle, <code>db</code> can be seen as a special case of
<code>select</code>. The following two queries are equivalent:

<p><pre><code>
: (? (db nm +Person "Edward" @P))
 @P={2-;}
 @P={2-1B}
 @P={2-R}
 @P={2-1K}
 @P={2-a}
 @P={2-T}
-> NIL
: (? (select (@P) ((nm +Person "Edward"))))
 @P={2-;}
 @P={2-1B}
 @P={2-R}
 @P={2-1K}
 @P={2-a}
 @P={2-T}
-> NIL
</code></pre>


<p><hr>
<h2><a name="sql">Poor Man's SQL</a></h2>

<h3>select</h3>

<p>For convenience, a <code>select</code> Lisp glue function is provided as a
frontend to the <code>select</code> predicate. Note that this function does not
evaluate its arguments (it is intended for interactive use), and that it
supports only a subset of the predicate's functionality. The syntax resembles
SELECT in the SQL language, for example:

<p><pre><code>
# SELECT * FROM Person
: (select +Person)  # Step through the whole database
{2-o} (+Man)
   nm "Adalbert Ferdinand Berengar Viktor of Prussia"
   dat 688253
   ma {2-j}
   pa {2-h}
   fin 711698

{2-1B} (+Man)
   nm "Albert Edward"
   dat 664554
   job "Prince"
   mate {2-f}
   kids ({2-1C} {2-1D} {2-1E} {2-1F} {2-1G} {2-1H} {2-1I} {2-g} {2-a})
   fin 680370
...
</code></pre>

<p><pre><code>
# SELECT * FROM Person WHERE nm LIKE "%Edward%"
: (select +Person nm "Edward")  # Show all Edwards
{2-;} (+Man)
   nm "Edward"
   dat 717346
   job "Prince"
   ma {2-:}
   pa {2-A}

{2-1B} (+Man)
   nm "Albert Edward"
   dat 664554
   job "Prince"
   kids ({2-1C} {2-1D} {2-1E} {2-1F} {2-1G} {2-1H} {2-1I} {2-g} {2-a})
   mate {2-f}
   fin 680370
...
</code></pre>

<p><pre><code>
# SELECT nm, dat FROM Person WHERE nm LIKE "%Edward%"
: (select nm dat +Person nm "Edward")
"Edward" "1964-03-10" {2-;}
"Albert Edward" "1819-08-26" {2-1B}
"George Edward" NIL {2-R}
"Edward Augustus Hanover" NIL {2-1K}
...
</code></pre>

<p><pre><code>
# SELECT dat, fin, p1.nm, p2.nm
#    FROM Person p1, Person p2
#    WHERE p1.nm LIKE "%Edward%"
#    AND p1.job LIKE "King%"
#    AND p1.mate = p2.mate  -- Actually, in a SQL model we'd need
#                           -- another table here for the join
: (select dat fin nm (mate nm) +Person nm "Edward" job "King")
"1894-06-23" "1972-05-28" "Edward VIII" "Wallace Simpson" {2-T}
"1841-11-09" NIL "Edward VII" "Alexandra of Denmark" {2-a}
-> NIL
</code></pre>


<h3>update</h3>

<p>In addition (just to stay with the SQL terminology ;-), there is also an
<code>update</code> function. It is a frontend to the 'set!>' and 'put!>'
transaction functions, and should be used when single objects in the database
have to be modified by hand.

<p>In principle, it would also be possible to use the <code>edit</code> function
to modify a database object. This is not recommended, however, because
<code>edit</code> does not know about relations to other objects (like Links,
Joints and index trees) and may easily cause database corruption.

<p>In the most general case, the value of a property in a database object is
changed with the <code>put!></code> function. Let's look at "Edward" from the
previous examples:

<p><pre><code>
: (show '{2-;})
{2R} (+Man)
   job "Prince"
   nm "Edward"
   dat 717346
   ma {2-:}
   pa {20A}
-> {2-;}
</code></pre>

<p>We might change the name to "Johnny" with <code>put!></code>:

<p><pre><code>
: (put!> '{2-;} 'nm "Johnny")
-> "Johnny"
</code></pre>

<p>However, an easier and less error-prone prone way - especially when more than
one property has to be changed - is using <code>update</code>. It presents the
value cell (the list of classes) and then each property on its own line,
allowing the user to change it with the <a href="#ledit">command line
editor</a>.

<p>Just hitting <code>RETURN</code> will leave that property unchanged. To
modify it, you'll typically hit <code>ESC</code> to get into command mode, and
move the cursor to the point of change.

<p>For properties with nested list structures (<code>+List +Bag</code>),
<code>update</code> will recurse into the data structure.

<p><pre><code>
: (update '{2-;})
{2-;} (+Man)      # RETURN
nm "Johnny"       # Modified the name to "Johnny"
ma {2-:}          # RETURN
pa {2-A}          # Return
dat 1960-03-10    # Modified the year from "1964" to "1960"
job "Prince"      # Return
-> {2-;}
</code></pre>

<p>All changes are committed immediately, observing the rules of database
synchronization so that any another user looking at the same object will have
his GUI updated correctly.

<p>To abort <code>update</code>, hit <code>Ctrl-X</code>.

<p>If only a single property has to be changed, <code>update</code> can be
called directly for that property:

<p><pre><code>
: (update '{2-;} 'nm)
{2-;} nm "Edward"
...
</code></pre>


<p><hr>
<h2><a name="ref">References</a></h2>

<p><a name="knuth73">[knuth73]</a> Donald E. Knuth: ``The Art of Computer
Programming'', Vol.3, Addison-Wesley, 1973, p. 392

</body>
</html>
